{"./":{"url":"./","title":"前言","keywords":"","body":" SELECT * FROM LEARNS WHERE LIVE IS NOT NULL 索引 这里只会记录本人的学习笔记，若需要访问本人博客，请 点我 进行访问。 在线访问我的笔记 蒲东平的博客 - 新 蒲东平的博客 - 旧 蒲东平的编程笔记 GiteePages GithubPages 当前笔记目录 Python 系列 python 基础语法 python 的基本数据类型 python 类型判断 python 错误、异常处理、记录日志 python IO 编程 python 函数以及传参 python 模块 python 类与对象 python 高阶函数 python 高级特性 Git 系列 git 相关命令 git bug 分支 git 标签 Docker 系列 docker 常见命令 laradock 笔记 JavaScript 系列 JavaScript 基础语法 JavaScript 基本数据类型 JavaScript 操作文件 JavaScript 操作DOM JavaScript 操作表单 JavaScript 浏览器对象 JavaScript 错误处理 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-11 22:48:34 "},"doc/python-notes/basic-grammar.html":{"url":"doc/python-notes/basic-grammar.html","title":"python 基础语法","keywords":"","body":" python 基础语法 python 中只有两种循环方式 for 和 while 可以使用 continue 和 break 关键字 # for 循环 for x in list(range(5)): if n % 2 == 0: # 只取奇数 continue print(x) # while 循环 sum = 0 n = 5 while n > 0: if n input 交互式输入 # input 返回值为 string a_input = input('Please give a number:') if a_input == '1': print('This is a good one') elif a_input == str(2): print('See you next time') else: print('Good luck') 三元表达式 # 条件为真时返回的结果 if 条件判断 else 条件为假时的返回结果 x if x > y else y 用字典映射代替 switch case 语句 ''' 用字典映射代替 switch case 语句 ''' day = 6 def get_sunday(): return 'sunday' def get_monday(): return 'monday' def get_tuesday(): return 'tuesday' def get_default(): return 'Unkown' switcher = { 0 : get_sunday, 1 : get_monday, 2 : get_tuesday } # 调用方法时，需要添加最后一个括号 () day_name = switcher.get(day, get_default)() print(day_name) # Unkown Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:16:49 "},"doc/python-notes/data-type.html":{"url":"doc/python-notes/data-type.html","title":"python 的基本数据类型","keywords":"","body":"Python 的基本数据类型 1. Number：数字（整数、小数） 整数：int 10_000_000_000 和 10000000000 是完全一样的 浮点数：float （ python 默认就已经是双精度了） Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大） 布尔类型：bool （ True 和 False ） and => 逻辑与 or => 逻辑或 not => 逻辑非 复数：complex 其他语言对于浮点数会有：单精度（float）、双精度（double）其他语言对于整数会有：short、int、long 2/2 => 1.0 除法运算会自动转化成浮点数 2//2 => 1 整除（地板除） 1//2 => 0 ， 10 // 3 => 3 10 % 3 => 1 余数运算 2. str：字符串（序列） # 对字符串不转义 print(r'\\\\\\t\\\\') => \\\\\\t\\\\ # 表示多行内容时 print('''line1 line2 line3''') # 只有一个参数时 'Hello, %s' % 'world' => 'hello, world' # 多个参数时 'Hello, %s: your age is %d' % ('alex', 26) => 'Hello, alex: your age is 26' f-string 方式格式化字符串 r = 3.5 s = 3.1415926 print(f'The r is {r} and the s is {s:.2f}') # .2f 表示保留两位小数 The r is 3.5 and the s is 3.14 3. 组（序列） 列表: list （可变化的有序表） list 是一种有序的集合，可以随时添加和删除其中的元素。 # 申明一个空列表 list1 = [] # 或者 list1 = list() # 嵌套列表 list1 = [1, 2, 3, 'hello', 'world', True, False, [5,6,7]] list1[0] => 1 # 取出第一个元素 list1[-1] 或者 list1[(len(list1) -1)] => [5,6,7] # 取出最后一个元素 # 追加元素到末尾 list1.append('alex') # 插入元素到指定位置 list1.insert(3, 'alex') # 删除末尾的元素 list1.pop() # 删除指定位置的元素（索引位置） list1.pop(3) # 更新指定位置元素 list1[3] = 'alex' # 从小到大排序 list1.sort() # 从大到小排序 list1.sort(reverse=True) 元组: tuple （不可变化的有序表：指向不变） tuple 一旦初始化就不能修改。 # 定义一个空 tuple tuple1 = () # 或者 tuple1 = tuple() # 比较特殊的现象 (1) 为 int 类型，是因为：小括号在 python 中表示数学运算优先级，因此定义一个元素的 tuple 时，必须加一个逗号，来消除歧义，python 在显示一个元素的 tuple 时，也会加一个逗号，以免开发人员误解成数学计算意义上的括号 tuple2 = (1,) tuple1 = (1, '-1', True, False) # 也可以这么定义（不加括号） tuple2 = 1, '-1', True, False tuple1[0] => 1 # 取出第一个元素 # 理解 *指向不变* t = ('a', 'b', ['A', 'B']) t[2][0] = 'X' t[2][1] = 'Y' # 以上结果同样成立，因为 t 中的 list 本身是可变的，但是 `t[2][2] = 'Z'` 则会报错，因此，tuple 的每个元素，指向永远不变。 4. set：集合 （不会有重复的值） set 和 dict 的唯一区别仅在于没有存储对应的 value, set 可以看成数学意义上的无序和无重复元素的集合 # 申明一个空的 set s = set() # 提供一个 list 作为输入集合，重复元素会在 set 中自动被过滤掉 s = set([2, 3, 4, 4, 5, 1, 1]) # 放入一个字典作为输入集合 ss = set({1, 2}) s.add(6) # 添加新元素到 set 中 s.add(5) # 重复添加元素到 set 中，可以添加，但是不会有效果 s.remove(4) # 删除元素 s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) # 两个集合的交集 join_s = s1 & s2 # print(join_s) => {2, 3} # 两个集合的并集 union_s = s1 | s2 # print(union_s) => {1, 2, 3, 4} # 两个集合的差集 c_s = s1 - s2 # print(c_s) => {1} c_s1 = s2 -s1 # print(c_s1) => {4} 5. dict：字典 dict 全 称dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。 不允许有重复的 key key 必须为不可变的类型，比如：int、str 特点有： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict 是用空间来换取时间的一种方法。 # 申明一个空的字典 dict1 = {} # 或者 dict1 = dict() dict1 = {'name': 'harry', 'age': 26} # 取出字典中的某个值 name = dict1['name'] # 或者 name = dict1.get('name') # 向字典中增加一个元素 dict1['sex'] = 1 # 修改字典中的某个值 dict1['name'] = 'alex' # 避免 key 不存在的情况，有两种方法 # 1、判断字典中的 key 是否存在，存在时为 True 不存在时为 False a = 'name' in dict1 # 2、直接尝试从字典中取 key 所对应的值，如果不存在则返回 None ，或者可以提供 get 的第二个参数，返回自定义的 value print(dict1.get('name1')) print(dict1.get('name1', 'jack')) # 删除一个 key dict1.pop('name') print(dict1) 6. None 空值 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:36:31 "},"doc/python-notes/type.html":{"url":"doc/python-notes/type.html","title":"python 类型判断","keywords":"","body":"python 类型判断 判断基本数据类型 t1 = type(123) == type(456) print(t1) # True t2 = type(123) == int print(t2) # True t3 = type('a') == type('1') print(t3) # True t4 = type('a') == str print(t4) # True t5 = type(123) == type('123') print(t5) # False t6 = isinstance('a', str) print(t6) # True t7 = isinstance(123, (list, int, str)) print(t7) # True 判断一个对象是否是函数 import types def fn(): pass t1 = type(fn) == types.FunctionType # types 模块中定义的常量 print(t1) # True t2 = type(abs)==types.BuiltinFunctionType print(t2) # True t3 = type(lambda x: x)==types.LambdaType print(t3) # True t4 = type((x for x in range(10)))==types.GeneratorType print(t4) # True Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:25:17 "},"doc/python-notes/handle-err.html":{"url":"doc/python-notes/handle-err.html","title":"python 错误、异常处理、记录日志","keywords":"","body":"python 错误、异常处理、记录日志 异常 import logging try: print('try...') r = 10 / 0 print('result:', r) except ValueError as e: # 所有的错误实例都是从 BaseException 类派生的 print('ValueError:', e) except ZeroDivisionError as e: # print('except:', e) logging.exception(e) # 记录错误信息 # raise => raise 语句如果不带参数，就会把当前错误原样抛出 # raise ValueError('input error!') => 还可以把一种类型的错误转化为另一种类型 else: # 如果没有错误发生时，会自动执行 else 语句。也可以不需要 else 语句 print('no error!') finally: # 不管是否异常，都会执行 finally 模块的代码。可以没有 finally 语句 print('finally...') print('END') # 常用的异常处理如下写法足矣 try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) 断言 assert def foo(s): n = int(s) assert n != 0, 'n is zero!' # 断言 n != 0 应该是 True 否则后面的代码肯定会出错，且此时 assert 会抛出 AssertionError 异常 return 10 / n foo('0') 记录日志 logging 日志级别优先级 debug import logging logging.basicConfig( level=logging.INFO, filename='runtime.log', datefmt='%Y-%m-%d %H:%M:%S', format=\"【%(asctime)s %(levelname)s】 %(lineno)d: %(message)s\" ) def foo(s): n = int(s) logging.debug('出错啦！') return 10 / n foo('0') Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:31:13 "},"doc/python-notes/io.html":{"url":"doc/python-notes/io.html","title":"python IO 编程","keywords":"","body":"python IO 编程 文件 IO 官方文档 open 函数 读文件 # 方式1: try: f = open('./runtime.log', 'r') # 文件不存在时，会抛出 IOError 错误 print(f.read()) # 读取文件的全部内容 finally: if f: f.close() # 文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的 # 方式2: # 使用 with 语句来自动调用 close() 方法，使得代码更加简洁，二者其实质性是一样的 with open('./runtime.log', 'r') as f: print(f.read()) # 一次性读取文件的全部内容 print(f.read(10)) # 每次最多读取 10 个字节的内容 print(f.readline()) # 每次读取一行内容 for line in f.readlines(): # 一次性读取所有内容并按行返回一个 list print(line.strip()) # 把末尾的 '\\n' 删掉 读二进制文件 # 读取二进制文件，比如图片、视频等，需要 `rb` 模式打开文件即可 f = open('./aa.jpg', 'rb') print(f.read()) # 返回十六进制表示的字节 字符编码 # 要读取非 utf-8 的文本文件时 f = open('./gbk.txt', 'r', encoding='gbk') print(f.read()) # 如果遇到编码不规范的文件时 f = open('./gbk.txt', 'r', encoding='gbk', errors='ignore') print(f.read()) 写文件 # 方式1: f = open('./runtime.log', 'a') # `w` 覆盖写入、`a` 追加写入、`wb` 写二进制文件 f = open('./runtime.log', 'a', encoding='gbk') # 如果需要写入非 utf-8 编码时 f.write('Hello Alex') f.close() # 必须要关闭文件，只有调用了 close() 方法时，操作系统才保证把没有写入的数据全部写入磁盘 # 方式2: # 不用自己调用 close() 方法关闭文件 with open('./runtime.log', 'w') as f: f.write('Hello Alex') 操作文件和目录 # 查看当前目录的绝对路径 abs_path = os.path.abspath('.') print(abs_path) # /Users/pudongping/glory/codes/python/document-converter # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来 # 路径拼接时，需要通过 os.path.join() 函数来操作，避免不同操作系统的路径分隔符不一致导致出错 new_path = os.path.join(abs_path, 'demodir/abc/cc') print(new_path) # /Users/pudongping/glory/codes/python/document-converter/demodir/abc/cc # 如果只需要创建一个目录时 os.mkdir(new_path) # 创建多层级的目录时 os.makedirs(new_path) # 删除一个目录 os.rmdir(new_path) # 拆分路径 path_split = os.path.split(new_path) # 后一部分总是最后级别的目录或文件名 print(path_split) # ('/Users/pudongping/glory/codes/python/document-converter/demodir/abc', 'cc') runtime_path = os.path.join(abs_path, 'runtime.log') print(runtime_path) # /Users/pudongping/glory/codes/python/document-converter/runtime.log runtime_split = os.path.split(runtime_path) print(runtime_split) # ('/Users/pudongping/glory/codes/python/document-converter', 'runtime.log') # 可以直接得到文件扩展名 runtime_split_text = os.path.splitext(runtime_path) print(runtime_split_text) # ('/Users/pudongping/glory/codes/python/document-converter/runtime', '.log') # 对文件重命名 os.rename(runtime_path, 'runtime1.log') # 复制文件 # 复制文件的函数在 os 模块中不存在 import shutil shutil.copyfile('./runtime1.log', 'runtime.log') # 删除文件 os.remove('./runtime1.log') json 转换 如果需要对类转 json 时，可以参考 json 进阶 import json d = dict(name='alex', age=26, city='Chongqin') # 转换为 json 字符串 json_encode = json.dumps(d) print(json_encode) # {\"name\": \"alex\", \"age\": 26, \"city\": \"Chongqin\"} print(type(json_encode)) # # 对中文序列化时 d = dict(name='张三', age=26, city='Chongqin') json_encode = json.dumps(d, ensure_ascii=False) print(json_encode) # {\"name\": \"张三\", \"age\": 26, \"city\": \"Chongqin\"} # 把 json 反序列化为 python 对象 json_decode = json.loads(json_encode) print(json_decode) # {'name': 'alex', 'age': 26, 'city': 'Chongqin'} print(type(json_decode)) # Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:33:01 "},"doc/python-notes/func.html":{"url":"doc/python-notes/func.html","title":"python 函数以及传参","keywords":"","body":"python 函数以及传参 参数组合时，必须按照： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数的顺序使用 技巧 对于任意函数，都可以使用 func(*args, **kw) 的形式调用 *args 是可变参数，args 接收的是一个 tuple**kw 是关键字参数，kw 接收的是一个 dict def tt(name, age, *, city='Shanghai', job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) args = ('alex', 26) kw = {'city': 'Chongqin', 'job': 'Coder'} tt(*args, **kw) 默认参数 def tt(name, age=18): print(f'the name is {name}') print(f'the age is {age}') tt('alex', 26) # output # the name is alex # the age is 26 多个默认参数时 def tt(name, age=18, gender=1, city='Shanghai'): print(f'the name is {name}') print(f'the age is {age}') print(f'the gender is {gender}') print(f'the city is {city}') tt('alex') tt('alex', 26, 0, 'Hubei') tt('alex', 26, 12, city='Chongqing') tt(city='Hubei', gender=0, name='zhangsan') 可变参数 *（参数的个数不确定） def cacl(numbers): sum = 0 for n in numbers: sum = sum + n return sum # 调用的时候需要先组装成一个 list 或者一个 tuple res = cacl([1, 2, 3]) res = cacl((1, 2, 3)) print(res) # 将参数更改为可变参数 def cacl(*numbers): print(type(numbers)) # 为一个元组 tuple sum = 0 for n in numbers: sum = sum + n return sum # 调用的时候则可以直接传参，不再需要转换成 list 或者 tuple res = cacl(1, 2, 3) print(res) # 如果已经存在了一个 list 或者一个 tuple 时，则只需要将 list 或者 tuple 的元素转变成可变参数传进去即可 numbers = [1, 2, 3] # 或者 numbers = (1, 2, 3) res = cacl(*numbers) print(res) 关键字参数 ** def tt(name, age, **kwargs): print('name: ', name, 'age: ', age, 'keywords: ', kwargs) tt('alex', 26) # name: alex age: 26 keywords: {} tt('alex', 26, city='Shanghai', job='Coder') # name: alex age: 26 keywords: {'city': 'Shanghai', 'job': 'Coder'} extra = {'city': 'Shanghai', 'job': 'Coder'} tt('alex', 26, **extra) # name: alex age: 26 keywords: {'city': 'Shanghai', 'job': 'Coder'} 命名关键字参数 # 只接收 city 和 job 作为关键字参数 def tt(name, age, *, city, job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) tt('alex', 26, job='Coder', city='Shanghai') # 或者设置默认值 def tt(name, age, *, city='Shanghai', job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) tt('alex', 26, job='Coder') 函数多个返回结果 def demage(skill1, skill2): damage1 = skill1 * 3 damage2 = skill2 * 2 + 10 return damage1,damage2 # 返回结果类型为tuple print(type(demage(1, 2))) # 序列解包的方式接受返回值 skill1_demage, skill2_demage = demage(1, 2) print(skill1_demage, skill2_demage) Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:34:11 "},"doc/python-notes/module.html":{"url":"doc/python-notes/module.html","title":"python 模块","keywords":"","body":"python 模块 官方第三方模块库Anaconda 是基于 Python 的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库 模块 （Module） 一个 .py 文件就是一个 python 模块（Module） 包 （Package） 一个目录就是一个包 每一个包目录下面都会有一个 __init__.py 的文件，这个文件是 必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。 __init__.py 可以是空文件，也可以有Python代码，因为init.py本身就是一个模块，而它的模块名就是文件夹的名称 demo1 ├─ __init__.py ├─ abc.py └─ xyz.py abc.py 的模块名就为 demo1.abc 自己创建模块时要注意命名，不能和 Python 自带的模块名称冲突。例如，系统自带了 sys 模块，自己的模块就不可命名为 sys.py ，否则将无法导入系统自带的 sys 模块。 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在 Python 交互环境执行 import abc ，若成功则说明系统存在此模块 模块的写法 hello.py #!/usr/bin/env python3 # 第 1 行：可以让这个 hello.py 文件直接在 Unix/Linux/Mac 上运行 # -*- coding: utf-8 -*- # 第 2 行：表示 .py 文件本身使用标准 UTF-8 编码 ' a test module ' # 第 4 行： 是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释； __author__ = 'Alex Pu' # 第 6 行： 使用__author__变量把作者写进去 import sys def test(): args = sys.argv # sys模块有一个 argv 变量，用 list 存储了命令行的所有参数。 if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!') if __name__=='__main__': test() # 执行代码 # python3 hello.py => Hello, world! # python3 hello.py alex => Hello, alex! 作用域 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__，__name__ 就是特殊变量，hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc，__abc 等； 但是 python 并没有一种方法可以完全限制访问 private 函数或变量！ import 载入模块 # 方法01、直接载入 import time print(time.localtime()) # 方法02、直接载入并别名 import time as t print(t.localtime()) # 方法03、只载入 time 模块的部分功能 from time import localtime,time print(localtime()) # 方法04、载入 time 模块的全部功能 from time import * print(localtime()) Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:37:54 "},"doc/python-notes/class.html":{"url":"doc/python-notes/class.html","title":"python 类与对象","keywords":"","body":"python 类与对象 类与对象 定义最简单的类 class Student(object): # 类变量 name = 'init name' age = 0 def __init__(self): pass def do_homework(self): pass student1 = Student() student2 = Student() # 打印出对象实例的内存地址 # print(id(student1)) # 1989045387336 # print(id(student2)) # 1989045405384 # __dict__ 保存着当前对象实例下所有的变量 print(student1.__dict__) # {} print(student2.__dict__) # {} 类变量和实例变量 python 会先从对象的实例变量中查找变量，如果找不到，则会从类变量中查找，如果本类中依然找不到类变量，则会从父类中继续去查找 优先级为：对象的实例变量 > 类变量 > 父类类变量 class Student(object): # 类变量只是和类相关联在一起的 name = 'init name' age = 0 # 这里的形参是实例变量，实例变量只是和对象实例关联在一起的 def __init__(self, name1, age1): # self.name 类似于这样的，就是定义并赋值给实例变量（实例变量初始化） self.name = name1 self.age = age1 def do_homework(self): pass student1 = Student('alex', 26) student2 = Student('harry', 25) print(student1.__dict__) # {'name': 'alex', 'age': 26} print(student2.__dict__) # {'name': 'harry', 'age': 25} print(Student.__dict__) # {'__module__': '__main__', 'name': 'init name', 'age': 0, '__init__': , 'do_homework': , '__dict__': , '__weakref__': , '__doc__': None} # 访问实例变量 print(student1.name) # alex print(student2.name) # harry # 访问类变量 print(Student.name) # init name 实例变量和类变量的区别 class Student(object): name = 'alex' # 类属性 s = Student() # 创建实例对象 s # 打印 name 属性，因为实例没有 name 属性，所以会继续查找 class 的 name 属性 print(s.name) # alex # 打印 class 的 name 属性 print(Student.name) # alex # 给实例对象 s 绑定 name 属性 s.name = 'Harry' # 由于实例属性优先级比类属性高，因此，会屏蔽掉 class 的 name 属性 print(s.name) # Harry # 但是 class 属性并没有消失，类属性还是可以访问 print(Student.name) # alex # 删除掉实例对象 s 的属性 del s.name # 由于实例对象 s 的属性没有找到，因此此时会显示出 class 的 name 属性 print(s.name) # alex 使用 slots 限制实例的属性 __slots__ 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义 __slots__ ，这样，子类实例允许定义的属性就是自身的 __slots__ 加上父类的 __slots__ class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称，不在此 tuple 中的属性将不能通过实例绑定 s = Student() s.name = 'alex' s.age = 26 # 当尝试绑定除了 __slots__ 之外的属性时，会报错 s.city = 'Chongqin' # 会报错 实例方法 class Student(object): # 类变量 all_students = 0 # 这里的 self 可以随便命名，比如说 this、aa、bb 都可以，但是建议命名为 self # self 代表的是实例对象，而不是类 # 构造方法可以看成比较特殊的实例方法 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 实例方法 def cal_all_students(self): print(self.name) # 实例方法中访问实例变量 # 访问类变量 print(Student.all_students) # 实例方法中访问类变量 print(self.__class__.all_students) # 这种方式也可以访问类变量 student1 = Student('alex', 26) student2 = Student('harry', 25) # 访问实例变量 print(student1.name) # alex print(student2.name) # harry # 访问实例方法 student1.cal_all_students() 类方法 class Student(object): # 类变量 all_students = 0 # 构造方法可以看成比较特殊的实例方法 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 类方法：用于操作和类相关的变量 @classmethod def cal_all_students(cls): # 类方法中不可以调用实例变量 # print(cls.name) # 会报错，因为此时实例还未创建 cls.all_students += 1 print('当前所有的学生人数为：%s' % cls.all_students) student1 = Student('alex', 26) # 访问类方法 Student.cal_all_students() # 当前所有的学生人数为：1 # 也可以通过实例对象去访问类方法，但是不建议这么去操作，因为不符合逻辑 # student1.cal_all_students() student2 = Student('harry', 25) Student.cal_all_students() # 当前所有的学生人数为：2 类方法和实例方法的比较：实例方法关联实例对象本身，类方法关联类本身。操作和对象无关的方法还是建议使用类方法（约定俗成） 静态方法（不常用，也不是很建议用） class Student(object): # 类变量 all_students = 0 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 静态方法：不经常用，当你自己觉得这个方法与类或者对象没有关联的时候可以使用，但是原则性来说，不要经常用 @staticmethod def add(x, y): s = x + y # 静态方法中不可以访问实例变量 # print(self.name) 会报错，因为没有 self print('静态方法中访问类变量： all_students 为 => %s' % Student.all_students) print('x + y 的结果为： %d' % s) student1 = Student('alex', 26) # 调用静态方法 student1.add(1, 2) # x + y 的结果为： 3 Student.add(3, 4) # x + y 的结果为： 7 私有类变量 类的私有变量 private 通过给属性的名称前加上两个下划线 __ 实现。这样的变量外部实例是无法访问的，因为实质性是把改属性的名称改成了 _类名__属性名 class Student(object): def __init__(self): self.__name = 'alex' self.age = 26 def tt(self): pass print(Student().__name) # 会直接报错，没有 __name 属性 print(Student()._Student__name) # alex 获取对象的属性或属性方法 print(dir(Student)) # 罗列出一个对象的所有属性和方法 # 判断是否有 age 属性 print(hasattr(Student(), 'age')) # True print(hasattr(Student(), '__name')) # False 这里为 False ，是因为 __name 属性定义为 private 属性，被 python 改名为 _Student__name print(hasattr(Student(), '_Student__name')) # True # 设置属性 obj = Student() setattr(obj, 'gender', 1) print(hasattr(obj, 'gender')) # True # 获取属性 print(getattr(obj, 'gender')) # 1 # 属性不存在时，设置一个默认值 print(getattr(obj, 'city', 'Shanghai')) # Shanghai print(getattr(obj, 'gender', 100)) # 1 # 判断是否有 tt 属性方法 print(hasattr(obj, 'tt')) # True fn = getattr(obj, 'tt') # 获取类方法 tt，并赋值给变量 fn，调用 fn() 和 tt() 是一样的效果 子类继承父类 ./c2.py class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) def do_homework(self): print('This is parent do_homework') ./c1.py from c2 import Human # 继承了 Human 父类 class Student(Human): def __init__(self, school, name, age): self.school = school # 子类调用父类的构造函数 super(Student, self).__init__(name, age) def do_homework(self): # 子类调用父类的同名方法 super(Student, self).do_homework() print('english homework') student1 = Student('半月小学', '小石头', 18) # 子类和父类都有同名方法，那么会优先返回子类结果 student1.do_homework() 枚举类 简单枚举，使用默认值 from enum import Enum Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) # 可以直接使用 Month.Jan 来引用一个常量 print(Month.Jan) # Month.Jan # 枚举所有成员 for name, member in Month.__members__.items(): # the name is => [Jan] and the member is => [Month.Jan] and the member default value is => [1] # value 属性则是自动赋给成员的 int 常量，默认从 1 开始计数 print(f'the name is => [{name}] and the member is => [{member}] and the member default value is => [{member.value}]') 自定义修改枚举值 from enum import Enum, IntEnum, unique # @unique 装饰器可以检查保证没有重复值 # IntEnum 可以限制枚举值必须为数字类型 @unique class Weekday(IntEnum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 day1 = Weekday.Mon print(day1) # Weekday.Mon print(Weekday.Mon) # Weekday.Mon print(Weekday['Mon']) # Weekday.Mon print(day1 == Weekday.Mon) # True print(day1 == Weekday.Tue) # False print(Weekday(1)) # Weekday.Mon print(day1 == Weekday(1)) # True # 获取枚举值 print(Weekday.Mon.value) # 1 # 获取枚举标签的名称 print(Weekday.Mon.name) # Mon # 枚举类型转换 # 以枚举值去找枚举类型 print(Weekday(3)) # Weekday.Wed Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:39:15 "},"doc/python-notes/high-func.html":{"url":"doc/python-notes/high-func.html","title":"python 高阶函数","keywords":"","body":"python 高阶函数 map map() 函数接收两个参数，一个是函数，一个是 Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。 # 把这个 list 所有数字转为字符串 l = list(map(str, [1, 2, 3, 4])) print(l) # ['1', '2', '3', '4'] reduce reduce 把一个函数作用在一个序列 [x1, x2, x3, ...] 上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 自己实现字符串转整型的方法 from functools import reduce DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9} def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) print(str2int('139')) # 139 filter filter 用于过滤序列，和 map() 类似，filter() 也接收一个函数和一个序列。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。 过滤序列中的空字符串 def not_empty(s): return s and s.strip() l = list(filter(not_empty, ['A', '', 'B', None, 'C', ' '])) print(l) # ['A', 'B', 'C'] sorted sorted 可以对 list 进行排序，还可以接收一个 key 函数来实现自定义的排序。 l = sorted([36, 5, -12, 9, -21]) print(l) # [-21, -12, 5, 9, 36] # 根据绝对值做排序 l1 = sorted([36, 5, -12, 9, -21], key=abs) print(l1) # [5, 9, -12, -21, 36] zip zip 可以将两个 list 中的每一个元素进行合并。 l1 = [1, 2, 3, 88] l2 = [4, 5, 6] r1 = list(zip(l1, l2)) print(r1) # [(1, 4), (2, 5), (3, 6)] r2 = l1 + l2 print(r2) # [1, 2, 3, 88, 4, 5, 6] copy 和 deepcopy copy 只会复制父对象，子对象是公用的，deepcopy 会完全复制父对象和子对象 import copy a = [1,2,3,[5,6,7]] b = a # id为硬盘空间索引 print(id(a) == id(b)) # True # 浅复制 c = copy.copy(a) print(id(a) == id(c)) # False,说明 a和c不是同样的东西 d = copy.copy(a) print(id(a[1]) == id(d[1])) # True,说明子对象是相同的东西 a[1] = 555 print(a,d) # a => [1, 555, 3, [5, 6, 7]], b => [1, 2, 3, [5, 6, 7]] a[3][1] = 666 print(a,d) # a => [1, 555, 3, [5, 666, 7]], b => [1, 2, 3, [5, 666, 7]] # 深复制 import copy a = [1,2,3,[5,6,7]] b = copy.deepcopy(a) print(id(a)==id(b)) # False 完全是不一样的东西 函数作为返回值 （闭包函数） # 这里就是一个闭包函数 # 不需要立即求和时（懒计算） def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum # 返回的并不是求和结果，而是求和函数 f = lazy_sum(1, 3, 5, 7) # 调用函数时才会真正计算求和的结果 print(f()) # 16 # 当我们调用 lazy_sum() 时，每次调用都会返回一个新的函数，即使传入相同的参数 f1 = lazy_sum(1, 3, 5, 7) f2 = lazy_sum(1, 3, 5, 7) print(f1 == f2) # False 简单闭包（闭包 = 函数 + 环境变量） # 闭包 = 函数 + 环境变量 def curve_pre(): a = 25 def curve(x): return a*x*x return curve a = 10 f = curve_pre() print(f(2)) 对闭包理解容易犯错点 # 错误示例 # def f1(): # a = 10 # def f2(): # # a 被 python 认为是一个局部变量 # c = 20 # return f2 # f = f1() # ''' # 此时 f2 并不能是一个闭包 # ''' # print(f) # print(f.__closure__) def f1(): a = 10 def f2(): # 必须要引用外部的 a 变量，而不是重新给 a 变量赋值 c = 20 * a return f2 f = f1() ''' 此时 f2 就是一个闭包函数 ''' print(f) print(f.__closure__) 让变量可以临时保存 origin = 0 def factory(pos): def go(step): # 强制标注不是本地的局部变量 nonlocal pos new_pos = pos + step pos = new_pos return new_pos return go tourist = factory(origin) # 2 print(tourist(2)) # 5 print(tourist(3)) # 10 print(tourist(5)) 匿名函数 lambda 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果 l1 = list(map(lambda x: x * x, [1, 2, 3, 4])) print(l1) # [1, 4, 9, 16] # 匿名函数 lambda x: x * x 实际上就是 def f(x): return x * x # 关键字 lamdba 表示匿名函数，冒号前面的 x 表示函数参数 # 还可以将匿名函数赋值给一个变量，再利用变量来调改函数 f = lambda x: x * x print(f(5)) # 25 装饰器 decorator 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 定义装饰器 import time def decorator(func): def wrapper(): print(time.time()) func() return wrapper # 定义装饰器 这里的 [decorator] 和 上面的 def decorator 名称必须是一致的 @decorator def f1(): print('This is a function') # 调用方式没有改变 f1() 当调用装饰器中方法有多个且每个方法参数数量不一致时 import time def decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper @decorator def f1(func_name): print('This is a function named ' + func_name) @decorator def f2(func_name1, func_name2): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) f1('cc') f2('cc1', 'cc2') 当调用装饰器中方法有指定参数时 import time def decorator(func): def wrapper(*args, **kw): print(time.time()) func(*args, **kw) return wrapper @decorator def f1(func_name): print('This is a function named ' + func_name) @decorator def f2(func_name1, func_name2): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) @decorator def f3(func_name1, func_name2, **keyword): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) print(keyword) f1('cc') f2('cc1', 'cc2') f3('cc1', 'cc2', a=1, b=2, c='1,2,3') Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:41:02 "},"doc/python-notes/high-features.html":{"url":"doc/python-notes/high-features.html","title":"python 高级特性","keywords":"","body":"python 高级特性 切片 l = list(range(100)) l1 = l[0:3] # 取前三个数 # print(l1) # [0, 1, 2] l2 = l[:3] # 如果第一个索引是 0 ，还可以这么取前三个数 # print(l2) # [0, 1, 2] l3 = l[2:5] # 从索引 2 开始取值取 (5-2=3) 个元素出来 # print(l3) # [2, 3, 4] l4 = l[-10:] # 取后十个数 # print(l4) # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] l5 = l[:10:2] # 取前 10 个数，每隔 2 个取一个数 # print(l5) # [0, 2, 4, 6, 8] l6 = l[::10] # 所有的数，每隔 10 个取一个数 # print(l6) # [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] l7 = l[:] # 什么都不写，则原样复制一个 list # print(l7) # [0, 1, 2, 3, ……, 97, 98, 99] 迭代 如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple ，这种遍历我们称为迭代（Iteration）。只要作用于一个可迭代对象，for 循环就可以正常运行。 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} # 只迭代 key 时 for key in d: print(key) # a b c d e # 只迭代 value 时 for value in d.values(): print(value) # 1 2 3 4 5 # 同时迭代 key 和 value 时 for k,v in d.items(): print(f'the key is {k} and the value is {v}') # output # the key is a and the value is 1 # the key is b and the value is 2 # the key is c and the value is 3 # the key is d and the value is 4 # the key is e and the value is 5 # 如果是 list 的话，需要同时迭代索引和元素本身时 l = ['a', 'b', 'c', 'd'] for i, value in enumerate(l): print(i, value) # output # 0 a # 1 b # 2 c # 3 d 如何判断一个对象是否为可迭代的对象？ from collections.abc import Iterable a = isinstance([], Iterable) # True b = isinstance({}, Iterable) # True c = isinstance('abc', Iterable) # True d = isinstance((x for x in range(10)), Iterable) # True e = isinstance(50, Iterable) # False 列表生成式 （支持：列表、元组、集合、字典） 是 Python 内置的非常简单却强大的可以用来创建 list 的生成式 l = [x * x for x in range(1, 11)] print(l) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # 生成全排列 l1 = [m + n for m in 'ABC' for n in 'XYZ'] print(l1) # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] # for 后面的 if 是过滤条件，不能加 else l = [x for x in range(1, 11) if x % 2 == 0] print(l) # [2, 4, 6, 8, 10] # for 前面的 if else 是表达式，必须要加 else l1 = [x if x % 2 == 0 else -x for x in range(1, 11)] print(l1) # [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:42:46 "},"doc/git-notes/command.html":{"url":"doc/git-notes/command.html","title":"git 相关命令","keywords":"","body":"git 相关命令 生成 SSH Key ssh-keygen -t rsa -C \"youremail@xxx.com\" // 输入之后直接两次回车即可 查看 git 用户名和邮箱地址 // 查看用户名 git config user.name // 查看邮箱地址 git config user.email // 查看配置信息 git config --list // git config --global 当前用户全局 // git config --system 当前系统全局 // 修改用户名 git config --global user.name \"username\" // 修改邮箱地址 git config --global user.email \"email\" // 重新输入账号密码 git config --system --unset credential.helper // git config --list 或者 git config -l 查看 git 配置信息 初始化一个 git 仓库 git init 添加文件到 git 仓库 1. 添加文件到缓存区 git add // 比如添加 file.txt 文件： git add file.txt 2. 将缓存区文件提交到本地仓库 git commit -m \"add_file_message\" // 比如提交 file.txt 文件：git commit -m \"add file.txt\" 查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变） git diff // 还可以查看具体哪个文件做了什么修改 // 比如查看 readme.txt 做了什么修改 git diff HEAD -- readme.txt 查看当前仓库状态，任何时候都可以使用 git status 查看提交日志 // 查看全部 git log // 查看最后一次提交 git show // 查看倒数5条 git log -5 // 简化日志显示方式，并含有提交版本号 git log --pretty=oneline 比如： $ git log --pretty=oneline 44c9beb4c58543b89181829755be2c5e9781ba28 (HEAD -> master) append GPL 03112bdf101655c30df9b61e4bd325b2cbe3c090 add distributed 8a1386bd0fe677bca99d5a4ef26e87772a3eca71 wrote a readme file 别名 Alias git config --global alias.br \"branch\" # 创建/查看本地分支 git config --global alias.co \"checkout\" # 切换分支 git config --global alias.cb \"checkout -b\" # 创建并切换到新分支 git config --global alias.cm \"commit -m\" # 提交 git config --global alias.st \"status\" # 查看状态 git config --global alias.pullm \"pull origin master\" # 拉取分支 git config --global alias.pushm \"push origin master\" # 提交分支 git config --global alias.log \"log --oneline --graph --decorate --color=always\" # 单行、分颜色显示记录 git config --global alias.logg \"log --graph --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative\" # 复杂显示 git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 回退版本 // 回退当前版本的上一个版本 git reset --hard HEAD^ // 回退当前版本的上三个版本 git reset --hard HEAD^^^ // 回退当前版本的上100个版本 git reset --hard HEAD~100 // 回退指定版本，并将 「回退」动作作为一个版本提交 git revert 回退指定版本（多半是因为回退版本回退多了） git reset --hard 版本号前几位 // 比如回退到 以上查看日志中的 add distributed 这个提交版本 git reset --hard 44c9beb4c 查看提交版本号 commit id // 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 git reflog 撤销修改 1. 修改只在工作区，还没有添加到缓存区 （还没有 git add） git checkout -- filename // 比如 readme.txt 文件只是在工作区修改了，想回退到修改之前的提交的版本 git checkout -- readme.txt 2. 修改从工作区已经提交到了缓存区 （已经 git add） // 将缓存区的修改回退到工作区 git reset HEAD filename // 比如 readme.txt 文件的修改已经提交到缓存区了，但是想撤销修改分为两步 01.将缓存区的修改回退到工作区 git reset HEAD readme.txt 02.将在工作区的修改回退到和上一个版本一样 git checkout -- readme.txt 3. 修改已经从缓存区提交到了本地仓库 （已经 git commit） // 回退当前版本的上一个版本 git reset --hard HEAD^ 4. 将在暂存区的更改文件进行强制撤销。（想让之前已经提交到缓存区的文件覆盖工作区的文件） git checkout -f 5. 命令 git clean 作用是清理项目，-f 是强制清理文件的设置，-d 选项命令连文件夹一并清除 git clean -f -d 6. 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： git fetch origin git reset --hard origin/master 删除文件 1. 确实要删除该文件 // 比如以 test.txt 为例子 // 01 本地手动删除 test.txt 文件 rm test.txt 或者 rm -rf test.txt // 02 添加被删除的状态缓存区 git rm test.txt 或者 git add test.txt // 03 提交状态到本地仓库 git commit -m \"remove test.txt\" 2. 工作区误删了文件 // 01 工作区误删了 test.txt 文件 rm test.txt // 02 找回被误删的文件（撤销修改） git checkout -- test.txt // 用版本库中的版本替换掉工作区的版本 创建分支并切换到该分支 git checkout -b alex 或者 git switch -c alex //创建 alex 分支并切换到 alex 分支 //等同于以下两个命令 git branch alex // 创建 alex 分支 git checkout alex 或者 git switch alex // 切换到 alex 分支 合并指定分支到当前分支 // 比如当前位于 master 分支，欲将 alex 分支合并到 master 分支 git merge alex // 如果有冲突，解决步骤如下： 01 先查看冲突文件 git status 02 手动解决冲突文件 03 再次合并分支 git merge alex 04 添加修改到缓存区 git add . 05 提交到本地仓库 git commit -m \"merge fixed\" 查看分支的合并情况 git log --graph --pretty=oneline --abbrev-commit 或者直接使用 git log --graph 命令可以看到分支合并图。 // 设置别名查看所有的提交记录 git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 删除分支 // 合并代码之后删除分支 git branch -d 分支名 // 没有合并代码删除分支 git branch -D 分支名 // 删除远程分支（本地分支需要再次手动删除） git push origin -d 分支名 // 比如删除 alex 分支 git branch -d alex // 删除远程 alex 分支 git push origin -d alex 查看分支 // 只查看远程分支 git branch -r // 只查看本地分支 git branch // 查看所有远程分支和本地分支 git branch -a 拉取远程分支并创建同名本地分支 // 方法一（此方法建立的本地分支和远程分支会有映射关系） git checkout -b [本地分支名] origin/[远程分支名] 举例：git checkout -b alex origin/alex // 方法二（此方法建立的本地分支和远程分支没有映射关系） git fetch origin [远程分支名]:[本地分支名] 举例：git fetch origin alex:alex 查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现） git branch -vv 手动建立本地分支和远程分支的映射关系 git branch -u origin/[分支名] 或者 git branch --set-upstream-to origin/[分支名] 或者 git branch --set-upstream-to=origin/[远程分支名] [本地分支名] 推送分支 git push -u origin // 第一次推送的时候添加 -u 参数，给本地分支和远程分支创建连接关系，当第二次再次推送时，则不需要添加 -u 参数 比如：推送 dev 分支 git push origin dev 查看远程库的信息 git remote // 查看远程库更加详细的信息 // 这里可以看到抓取和推送的 origin 的地址 git remote -v （小写的v） // 删除远程库连接 git remote rm // eg：删除远程 origin 连接 git remote rm origin // 添加远程库连接 git remote add // eg: 关联本人 GitHub 连接，并连接名为 myGitHub git remote add myGitHub git@github.com:Alex66668888/demo.git 多处备份 一个 pull + 多个 push # 添加远程连接 $ git remote add origin git@gitee.com:pudongping/tt.git # 查看远程连接地址，可以看到只有一个 fetch 地址和一个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) # 添加 github 推送地址 $ git remote set-url --add origin git@github.com:pudongping/tt.git # 查看远程连接地址，可以看到只有一个 fetch 地址和两个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) origin git@github.com:pudongping/tt.git (push) # 添加 gitlab 推送地址 $ git remote set-url --add origin git@gitlab.com:pudongping/t1.git # 查看远程连接地址，可以看到只有一个 fetch 地址和三个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) origin git@github.com:pudongping/t1.git (push) origin git@gitlab.com:pudongping/tt.git (push) # 推送到远程分支，就可以看到已经同步到多个平台上去了，一次 push 到多个远程仓库 git push git add 三种状态命令比较 命令 说明 git add . 提交所有修改的和新建的数据暂存区 (提交当前文件夹下所有修改) git add -u 提交所有被删除和修改的文件到数据暂存区（等同于git add -update） git add -A 提交所有被删除、被替换、被修改和新增的文件到数据暂存区（等同于git add –all） 已经推送（push）过的文件，想从 git 远程库中删除，并在以后的提交中忽略，但是却还想在本地保留这个文件 git rm --cached [file-path] git rm --cached config/pay.php # 如果是目录的话，则需要 git rm -r --cached [dir_name] git push 已经推送（push）过的文件，想在以后的提交时忽略此文件，即使本地已经修改过，而且不删除 git 远程库中相应的文件 # 只对文件有效 git update-index --assume-unchanged [file-path] git update-index --assume-unchanged config/pay.php # 如果需要恢复提交 git update-index --no-assume-unchanged [file-path] 合并一个分支上的修改到当前分支 # 比如说 test1 分支上有一个提交 512d725 现在想将这个提交合并到 test2 分支上 # 先切换到 test2 分支上 git checkout test2 # 择优挑选（此时还是在 test2 分支上） git cherry-pick 512d725 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:48:03 "},"doc/git-notes/branch-bug.html":{"url":"doc/git-notes/branch-bug.html","title":"git bug 分支","keywords":"","body":"bug 分支 修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场 git stash 一下，然后去修复 bug，修复后，再 git stash pop，回到工作现场；在 master 分支上修复的 bug，想要合并到当前 dev 分支，可以用 git cherry-pick 命令，把 bug 提交的修改“复制”到当前分支，避免重复劳动。 应用场景如下：当你需要修改一个 bug，但是你当前的开发功能还不想提交到远程版本库中，又必须要先将 bug 提交。 查看当前工作区的状态（假设当前在 dev 分支） // 工作区的文件还没有提交 git status 存储当前的工作现场 git stash 再次查看工作区的状态，应该是干净的 如果需要在 master 分支上修复 bug，那么就需要从 master 分支上创建临时分支 // 切换到 master 分支 git checkout master // 创建修复 bug 的分支为 issue-1 git checkout -b issue-1 在 issue-1 分支上修复 bug 在 issue-1 分支上提交代码 git add -A && git commit -m 'fixed bug 1' 切换到 master 分支 git switch master 从 master 分支上合并 issue-1 分支的代码，并添加了合并信息 git merge --no-ff -m \"merged bug fix 1\" issue-1 原来是在 dev 分支上干活，现在切换到 dev 分支上继续干活 git checkout dev // 如果此时用 git status 命令查看的话，此时的工作区是干净的 查看之前临时存储的工作现场 git stash list 恢复工作现场（有两种方法） // 第一种方法： // 恢复工作现场 git stash apply // 删除之前临时存储的工作现场 git stash drop // 第二种方法： // 恢复的同时把 stash 内容也删了 git stash pop 如果需要恢复指定的工作现场 // 查看所有的工作现场 git stash list // 恢复名称为 「stash@{0}」 的工作现场 git stash apply stash@{0} 将修复好的 bug 同步到其他的分支 可以通过直接将修复 bug 的文件修改内容复制到其他分支，比如在 issue-1 分支上修复的提交版本号为 c55ae16d5b1a，现在只需要将这个版本号的所有修改内容复制到 dev 分支上即可。 // 当前分支为 dev git checkout dev // 复制一个特定的提交到当前分支（此操作会自动提交一个版本号） git cherry-pick c55ae16d5b1a Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:51:22 "},"doc/git-notes/tags.html":{"url":"doc/git-notes/tags.html","title":"git 标签","keywords":"","body":"Git 标签 标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。 创建标签 // 给当前提交版本打标签 git tag // eg: 打一个名称为 v1.0 的标签，此时默认将标签打到最新提交的 commit 上 git tag v1.0 给指定提交版本打标签 // 查看历史提交的 commit id git log --pretty=oneline --abbrev-commit // 给指定提交版本打标签 git tag // eg: 给提交版本号为 c53b867 的版本，打一个名称为 v0.8 的标签 git tag v0.8 c53b867 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字： git tag -a -m // eg：给版本号为 c53b867 的版本，打一个名称为 v0.8 的标签，并对 v0.8 这个标签添加说明文字为 \"add v0.8 tag\" git tag -a v0.8 -m \"add v0.8 tag\" c53b867 查看所有的标签 （标签不是按时间顺序列出，而是按字母排序的。） git tag 查看标签信息 git show // eg：查看标签名得 v0.9 的标签信息 git show v0.9 删除标签 git tag -d // eg：删除标签名为 v0.1 的标签 git tag -d v0.1 推送本地标签到远程库 git push origin // eg： 推送本地标签名为 v0.1 的标签到远程库中 git push origin v0.1 一次性推送全部尚未推送到远程的本地标签 git push origin --tags 如果标签已经推送到远程，想要删除远程标签 // 第一步：删除本地标签 git tag -d v0.1 // 第二步：从远程删除 git push origin :refs/tags/v0.1 // 第三步：在远程库中查看是否被删除 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:20:59 "},"doc/docker-notes/command.html":{"url":"doc/docker-notes/command.html","title":"docker 常见命令","keywords":"","body":"docker 常见命令 查看版本 docker -v 查看详细版本 docker version 查看 docker 基本信息 docker info 镜像相关的命令 镜像仓库地址：https://hub.docker.com 查看本地已经安装的镜像 docker images 搜索指定镜像 docker search # 比如搜索 centos 镜像 docker search centos 拉取镜像 docker pull # 比如拉取 centos 镜像（将会拉取最新版本的镜像，即 latest 版本） docker pull centos # 拉取指定版本的镜像 docker pull ubuntu:16.04 删除镜像 docker rmi # 比如删除 centos 镜像 docker rmi centos 删除所有的镜像 docker rmi $(docker images -q) # 查看所有镜像的镜像 id docker images -q 更新镜像 # 更新镜像前，需要使用镜像创建一个容器 docker run -it ubuntu:15.10 bash # 在运行的容器内部使用 apt-get update 更新 # 更新完毕之后，输入 exit 命令退出容器 # 使用 docker commit 来提交容器副本 docker commit -m=\"has update\" -a=\"alex\" e218edb10161 alex/ubuntu:v2 # -m 表示提交的描述信息 # -a 表示提交的镜像作者 # e218edb10161 表示容器的 id # alex/ubuntu:v2 表示指定要创建的目标镜像名 # 查看新的镜像 docker images # 使用新镜像 alex/ubuntu:v2 来启动一个容器 docker run -it alex/ubuntu:v2 bash 构建镜像 vim ~/glory/codes/book/demo/Dockerfile 填充以下内容，构建一个 centos 8 系统 # 指定使用哪个镜像源 FROM centos:8 # 如果写了 3 次 RUN 那么将会在 docker 上新建 3 层，会导致镜像膨胀过大，下面这种方式只会创建 1 层镜像 RUN /bin/echo 'root:123456' | chpasswd; \\ useradd alex; \\ /bin/echo 'alex:123456' | chpasswd; \\ /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" > /etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 开始构建镜像，注意不要在 ~/glory/codes/book/demo 目录下放无用的文件，因为会打包所有该目录下的文件然后发送给 docker 引擎，如果文件过多会造成 build 过程缓慢 # -t 表示指定要创建的目标镜像名 # ~/glory/codes/book/demo 表示 Dockerfile 文件所在的目录 docker build -t alex/centos:8.0 ~/glory/codes/book/demo # 查看已经构建好的镜像信息 docker images # 使用新的镜像来创建新容器 docker run -it alex/centos:8.0 bash 设置镜像标签 # 先查看镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alex/centos 8.0 594ab4747ed4 14 minutes ago 210MB # 设置镜像标签 $ docker tag 594ab4747ed4 alex1/centos1:8.1.1 # 再次查看镜像信息会多一个标签 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alex/centos 8.0 594ab4747ed4 14 minutes ago 210MB alex1/centos1 8.1.1 594ab4747ed4 14 minutes ago 210MB 容器相关的命令 查看容器的系统版本信息 # 进入容器后执行 cat /proc/version # 比如会输出以下内容 Linux version 4.19.121-linuxkit (root@18b3f92ade35) (gcc version 9.2.0 (Alpine 9.2.0)) #1 SMP Thu Jan 21 15:36:34 UTC 2021 查看所有的容器 docker ps -a # 或者使用以下命令，是一样的效果 docker container ls -a # 查看最后一次创建的容器 docker ps -l 查看所有已经运行的容器 docker ps 查看容器端口映射 docker port 查看 docker 底层信息（比如：查看指定容器的 ip 地址） # 查看 docker 容器的配置和状态信息 docker inspect # 查看容器的 ip 地址 docker inspect | grep IPAddress # 比如查看容器 id 为 66204be9fe65 的容器所对应的 ip 地址 docker inspect 66204be9fe65 | grep IPAddress # 比如查看容器名称为 alex 所对应的 ip 地址 docker inspect alex | grep IPAddress 创建容器并把镜像恢复到容器当中，且启动容器 docker run [-i][-t][-v][--name][-d][-p] # -i 表示 interactive 交互式 # -t 表示得到一个 terminal # --name 表示修改容器名称 # -d 表示以守护进程的方式运行（默认不会进入容器，想要进入容器则需要使用 docker exec 命令） # -p 表示 **指定** 映射端口 # -P （大写的字母 p ） 表示 **随机** 映射端口 # /bin/bash 和 bash 等效 docker run -it /bin/bash # 比如创建一个新容器并且进入 ubuntu:16.04 镜像 docker run -it ubuntu:16.04 bash # 或者 docker run -it ubuntu:16.04 /bin/bash # 或者 docker run -it ubuntu:16.04 # 以 centos 镜像创建一个新容器，并修改新容器名称为 alex-container docker run -it --name alex-container centos bash # 以守护进程的方式运行 （后台运行） docker run -d --name alex-container centos # 或者 docker run -di --name alex-container centos # 指定容器绑定的网络地址，这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口（默认绑定的都是 tcp 端口） docker run -d -p 127.0.0.1:5001:5000 centos:8.0 bash # 如果需要绑定 udp 端口，则 # （还可以进入容器就直接执行 python app.py 命令） docker run -d -p 127.0.0.1:5001:5000/udp centos:8.0 python app.py # 比如，安装 hyperf 镜像并启动容器 # 如果 docker 启动时开启了 selinux-enabled 选项，容器内访问宿主机资源就会受限，所以启动容器时可以增加 --privileged -u root 选项 docker run --name hyperf \\ -v /workspace/skeleton:/data/project \\ -p 9501:9501 -it \\ --privileged -u root \\ --entrypoint /bin/sh \\ hyperf/hyperf:7.4-alpine-v3.11-swoole 启动容器 docker start # 比如启动容器名称为 redis-alex 的容器 docker start redis-alex # 比如启动容器 id 为 c8c0c770ac5b 的容器 docker start c8c0c770ac5b 直接进入已经创建的容器（不会启动容器） docker start -i # 比如进入容器 id 为 66204be9fe65 的容器 docker start -i 66204be9fe65 # 比如进入容器名称为 alex 的容器 docker start -i alex 重启容器 docker restart # 比如重启容器名称为 redis-alex 的容器 docker restart redis-alex # 比如重启容器 id 为 c8c0c770ac5b 的容器 docker restart c8c0c770ac5b 进入已经运行中的容器 docker exec -it bash # 比如进入容器名称为 redis-alex 的容器 docker exec -it redis-alex bash # 比如进入容器 id 为 c8c0c770ac5b 的容器 docker exec -it c8c0c770ac5b bash # 进入容器之后执行 shell 命令或者执行 shell 脚本 docker exec -it /bin/sh -c \"while true; do echo hello world; sleep 1; done\" # 比如进入容器 id 为 c8c0c770ac5b 的容器，并且进入容器后执行 `bash /portal_api_dfo_hyperf/server.sh restart` 脚本 docker exec -it c8c0c770ac5b /bin/sh -c \"bash /portal_api_dfo_hyperf/server.sh restart\" 停止容器 docker stop # 比如停止容器名称为 redis-alex 的容器 docker stop redis-alex # 比如停止容器 id 为 c8c0c770ac5b 的容器 docker stop c8c0c770ac5b 退出容器 exit 删除容器 docker rm # 也可以加入 -f 参数，强制移除正在运行中的容器 docker rm -f 1e560fca3906 # 清理掉所有处于终止状态的容器 docker container prune 修改容器名称 docker rename # 比如将容器 redis-alex 改名为 redis-tt docker rename redis-alex redis-tt 查看容器的标准输出 docker logs # 比如查看容器 id 为 c8c0c770ac5b 的容器标准输出内容 docker logs c8c0c770ac5b # 也可以加入 -f 参数，像使用 tail -f 一样来输出容器内部的标准输出 docker logs -f c8c0c770ac5b 容器与宿主机之间的文件或者目录拷贝 从宿主机拷贝文件到容器中 docker cp : # 比如将宿主机中的 /home/alex/test.txt 文件拷贝到 centos1 容器中的 /test.txt docker cp /home/alex/test.txt centos1:/test.txt 从容器拷贝到宿主机中 docker cp : # 比如将 centos1 容器中的 /test 目录拷贝到宿主机的 /home/alex 目录下 docker cp centos1:/test /home/alex 目录挂载（创建容器的时候就需要进行目录挂载） docker run -di -v : # 在 windows 下挂载（注意路径的书写方式） # 比如以 centos 镜像创建一个容器，并将本地 D 盘中的 alex 目录，挂载到容器中的 /usr/local/demo 目录 docker run -di -v d:\\alex:/usr/local/demo centos # 在 linux 下挂载 # 比如以 centos 镜像创建一个容器，并将本地的 /home/alex/alex 目录，挂载到容器中的 /usr/local/demo 目录 docker run -di -v /home/alex/alex:/usr/local/demo centos 导出和导入容器 导出容器快照 docker export > # 比如将容器 id 为 7691a814370e 的容器导出快照为 alex.tar docker export 7691a814370e > alex.tar 导入容器快照 cat | docker import - /: # 比如将容器快照文件 alex.tar 导入到 alex-demo 镜像并定义 alex-demo 镜像的作者为 alex，版本号为 v1.0 cat alex.tar | docker import - alex/alex-demo:v1.0 # 此外，也可以通过指定 url 或者某个目录来导入 docker import http://example.com/example-image.tgz example/image-repo:v1.0 书籍 Docker -- 从入门到实战 Docker 边学边用 一文了解 Kubernetes Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:57:33 "},"doc/docker-notes/about-laradock.html":{"url":"doc/docker-notes/about-laradock.html","title":"laradock 笔记","keywords":"","body":"laradock 笔记 官方文档 中文文档 在 Mac/Windows 系统中使用 Laradock 搭建基于 Docker 的 Laravel 开发环境 安装步骤 首先将 Laradock 项目代码克隆到本地： git clone https://github.com/Laradock/laradock.git 进入 laradock 目录将 env-example 重命名为 .env： cp env-example .env 然后在 .env 中修改镜像构建过程中 Linux 软件源为国内镜像以免镜像构建过程中出现网络超时问题： CHANGE_SOURCE # If you need to change the sources (i.e. to China), set CHANGE_SOURCE to true CHANGE_SOURCE=true # Set CHANGE_SOURCE and UBUNTU_SOURCE option if you want to change the Ubuntu system sources.list file. UBUNTU_SOURCE=aliyun 构建镜像 & 启动容器： docker-compose up -d nginx mysql redis beanstalkd nginx 镜像构建在 php-fpm 之上，php-fpm 构建在 workspace 之上，所以启动 nginx 会先启动 workspace 和 php-fpm。 如果指定端口已经被占用，运行上述命令会报错，关闭相应的服务再重新运行上述命令即可。 如果在 Windows 系统中上述指令构建镜像过程中报错： /tmp/sources.sh: not found 可参考这个 issue 解决：https://github.com/laradock/laradock/issues/2450。 打开 Laravel 项目的 .env 文件并添加如下配置： DB_HOST=mysql # 这里填写容器的名称（比如：laradock_redis_1）或者容器的 ip 地址（比如：172.28.0.5）也可以 REDIS_HOST=redis QUEUE_HOST=beanstalkd 其他命令 构建镜像 & 启动容器 docker-compose up -d nginx mysql redis beanstalkd 重新构建容器 # 比如：重新构建 mysql 容器 docker-compose build mysql 增加一个项目之后,重启 Docker 的 nginx docker-compose up -d nginx 列出容器 # 列出正在运行的容器 docker ps # 如果你只想看当前这个项目的容器，你也可以执行下面这个命令 docker-compose ps 重启当前这个项目中的所有容器（如果你不想一个一个的开启每一个容器，可以方便的执行这条命令） docker-compose restart 关闭容器 # 关闭所有正在运行的容器 docker-compose stop # 停止单个容器 docker-compose stop {container-name} 进入容器 # 使用下面的命令进入任意容器 docker-compose exec {container-name} bash # 进入 mysql 容器 docker-compose exec mysql bash # 进入 mysql 并在 mysql 容器中使用命令提示符 docker-compose exec mysql mysql -u homestead -psecret # 进入 workspace 容器,执行比如(Artisan, Composer, PHPUnit, Gulp, ...)等命令 docker-compose exec workspace bash 删除所有现有容器 docker-compose down 查看日志文件NGINX 日志文件存储在logs/nginx目录中但是要查看其他容器（Mysql，PHP-FPM,...）的日志，可以运行以下命令 docker-compose logs {container-name} docker-compose logs -f {container-name} 在 laradock 中安装 swoole 在本地安装的话，以 Laradock 为例，需要在 laradock 目录下的 .env 中将下面两行配置值设置为 true： WORKSPACE_INSTALL_SWOOLE=true PHP_FPM_INSTALL_SWOOLE=true 然后运行 docker-compose build php-fpm workspace 重新构建 Docker 容器，构建完成后重启这两个容器，进入 workspace 容器，运行 php -m 查看 Swoole 是否安装成功，如果扩展列表包含 swoole 则表示安装成功。 其他需要注意事项 在 laravel 框架中，如果配置不生效，请注意清理下 laravel 的缓存 php artisan config:clear 检查下是否开启了 5200 端口 安装 netstat 命令，查看端口apt-get updateapt-get install net-toolsnetstat -ntlp netstat -ant | grep 5200 端口映射开启方式 进入 laradock/docker-compose.yml 在 workspace 下的 ports 中新增 ports: - \"${WORKSPACE_SSH_PORT}:22\" - \"${WORKSPACE_VUE_CLI_SERVE_HOST_PORT}:8080\" - \"${WORKSPACE_VUE_CLI_UI_HOST_PORT}:8000\" - \"${WORKSPACE_PORT}:5200\" /**这一行为新增的行，也可以直接在这里加 5200:5200 这样加了之后，就不再需要在 .env 中设置变量了**/ 进入 .env 在 WORKSPACE 下最后一行增加 WORKSPACE_AST_VERSION=1.0.3 WORKSPACE_VUE_CLI_SERVE_HOST_PORT=8080 WORKSPACE_VUE_CLI_UI_HOST_PORT=8001 WORKSPACE_INSTALL_GIT_PROMPT=false WORKSPACE_PORT=5200 /**这一行为新增的行，其实就是设置步骤 1 中的变量**/ 有些博客说还需要在 laradock/workspace/Dockerfile 文件的最后添加一行，申明开放端口： EXPOSE 5200，这里，我并没有做这一步，同样也成功了，如果你没有成功，你加上去之后再试试看吧 强制重新创建 workspace 容器 docker-compose up -d --force-recreate workspace 重启 docker-compose docker-compose restart docker ps 测试端口是否开通成功 telnet 127.0.0.1 5200 # 或者直接查看容器的端口列表中是否含有你所需要开通的端口 docker port {container-name} # 比如，如下 docker port laradock_workspace_1 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 09:02:31 "},"doc/javascript-notes/basic-grammar.html":{"url":"doc/javascript-notes/basic-grammar.html","title":"JavaScript 基础语法","keywords":"","body":"JavaScript 基础语法 代码书写位置 内嵌到网页中，一般将 JavaScript 代码放到 中 alert('Hello, world'); 单独一个 .js 文件，然后在 html 文件中去引入 JavaScript 并不强制要求在每个语句的结尾加 ; ，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上 ; 。 让 JavaScript 引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。因此，我们不会省略 ; ，所有语句都会添加 ; 。 比较运算 // 它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； false == 0; // true // 它不会自动转换数据类型，如果数据类型不一致，返回 false，如果一致，再比较。 false === 0; // false strict 模式 在 JavaScript 代码的第一行写上 'use strict'; 循环 for 循环 // for 循环 let x = 0; let i; for (i = 1; i while 循环 // while 循环 let x = 0; let n = 10; while (n > 0) { x += n; n -= 2; } console.log(x); // 30 // do ... while let n = 0; do { n += 1; } while (n forEach 循环 （ES5.1 标准引入） // 循环 set let s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element, sameElement, set); }); // 循环 map let m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(key, value, map); }); // 循环数组 let arr = ['A', 'B', 'C']; arr.forEach(function (item, index, array) { console.log(index, item, array); }); // 不可以使用 forEach 去遍历对象 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-08 10:11:16 "},"doc/javascript-notes/data-type.html":{"url":"doc/javascript-notes/data-type.html","title":"JavaScript 基本数据类型","keywords":"","body":"JavaScript 的基本数据类型 1. Number：数字 JavaScript 不区分整数和浮点数，统一用 Number 表示。 // NaN 表示 Not a Number，当无法计算结果时用 NaN 表示 NaN; // NaN 无法做比较，只能使用 isNaN() 函数判断 NaN === NaN; // false isNaN(NaN); // true // Infinity 表示无限大，当数值超过了 JavaScript 的 Number 所能表示的最大值时，就表示为 Infinity Infinity; 2. string：字符串 // 由于多行字符串用 \\n 写起来比较费事，所以最新的 ES6 标准新增了一种多行字符串的表示方法，用反引号 `……` 表示 let str = `this is multi lines string `; // 等同于如下代码 let str1 = 'this is\\n multi lines\\n string'; // 模板字符串 let name = 'alex'; let age = 26; let message = `hello, ${name}, are you ${age} years old ?`; console.log(message); // hello, alex, are you 26 years old ? // 操作字符串 name[3]; // \"x\" // 字符串全部转大写 let name1 = name.toUpperCase(); // \"ALEX\" // 字符串全部转小写 name1.toLowerCase(); // \"alex\" // 搜索指定字符串出现的位置 name.indexOf('l'); // 1 name.indexOf('jack'); // -1 没有找到指定的子串 // 截取字符串 name.substring(1, 3); // \"le\" 从索引 1 开始到 3 （不包括 3） name.substring(1); // \"lex\" 从索引 1 开始到结束 3. boolean： 布尔值 4. null： （空值） 和 undefined：（未定义） 大多数情况下，我们都应该用 null 。 undefined 仅仅在判断函数参数是否传递的情况下有用。 5. array：数组 // 声明新数组（建议直接使用这种方式声明） let new_arr = [1, 'Hello', null, true]; // 或者 let new_arr1 = new Array(1, 'Hello', null, true); // 获取元素 new_arr[1]; // 'Hello' // 修改元素 new_arr[1] = 'World'; new_arr; // [1, 'World', null, true] // 搜索指定元素的索引位置 new_arr.indexOf(null); // 2 // 截取数组 new_arr.slice(0, 3); // [1, \"Hello\", null] 从索引 0 开始，到索引 3 结束，但不包含索引 3 new_arr.slice(2); // [null, true] 从索引 2 开始到结束 new_arr.slice(); // [1, 'Hello', null, true] 从头到尾截取所有元素 // 往数组的末尾添加若干元素 new_arr.push('Jack', 'Alice'); // 6 返回 array 的新长度 // 删除最后一个元素 new_arr.pop(); // 'Alice' // 往数组的头部添加若干元素 new_arr.unshift('Jack', 'Alice'); // 6 返回 array 的新长度 // 删除第一个元素 new_arr.shift(); // 'Jack' // 对数组进行排序 let arr = ['B', 'C', 'A']; arr.sort(); arr; // [\"A\", \"B\", \"C\"] // 反转数组 let arr = ['Alice', 'Alex', 'Jack']; arr.reverse(); arr; // [\"Jack\", \"Alex\", \"Alice\"] // 从指定的索引开始删除若干元素，然后再从该位置添加若干元素 let arr = ['A', 'B', 'C', 'D', 'E', 'F']; // 从索引 2 开始删除 3 个元素，然后再添加 2 个元素 arr.splice(2, 3, 'C1', 'D1'); // [\"C\", \"D\", \"E\"] 返回删除的元素 arr; // [\"A\", \"B\", \"C1\", \"D1\", \"F\"] // 只删除，不添加 arr.splice(2, 2); // [\"C1\", \"D1\"] 返回删除的元素 arr; // [\"A\", \"B\", \"F\"] // 只添加，不删除 arr.splice(2, 0, 'X1', 'Y1'); // [] 因为没有删除任何元素，因此会返回空数组 arr; // [\"A\", \"B\", \"X1\", \"Y1\", \"F\"] // 将两个数组拼接起来 let arr = ['A', 'B', 'C']; let arr1 = arr.concat([1, 2, 3]); arr1; // [\"A\", \"B\", \"C\", 1, 2, 3] arr; // [\"A\", \"B\", \"C\"] // 会自动把数组拆开 let arr2 = arr.concat(1, 2, [3, 4]); arr2; // [\"A\", \"B\", \"C\", 1, 2, 3, 4] // 使用特定的字符串拼接每一个元素 let arr = ['A', 'B', 'C']; arr.join('-'); // \"A-B-C\" 6. object：对象 // 声明新对象（最后一个键值对不需要在末尾加逗号，有些低版本的浏览器会报错） let new_obj = {} let new_obj1 = { name: 'alex', age: 26, city: 'Chongqing', 'middle-school': 'No.1 Middle School' // 如果属性名包含特殊字符，就必须用单引号括起来 } // 获取元素 new_obj1.name; // \"alex\" new_obj1['name']; // \"alex\" new_obj1['middle-school']; // \"No.1 Middle School\" // 新增一个 tt 属性 new_obj1.tt = 'demo'; // \"demo\" // 修改属性 new_obj1.tt = 'demo1'; // \"demo1\" // 删除一个属性 delete new_obj1.age; // true new_obj1; // {name: \"alex\", city: \"Chongqing\", middle-school: \"No.1 Middle School\"} // 判断一个属性是当前对象独有的 new_obj1.hasOwnProperty('name'); // true new_obj1.hasOwnProperty('name1'); // false 7. Map（ES6 规范定义的新的数据类型） Map 是一组键值对的结构，具有极快的查找速度 // 声明一个空 map let m = new Map(); let m1 = new Map([['alex', 26], ['alice', 18], ['jack', 20]]); // 取值 m1.get('alex'); // 26 // 添加新的 key-value m1.set('angle', 24); // 修改指定 key 的 value m1.set('alex', 88); // {\"alex\" => 88, \"alice\" => 18, \"jack\" => 20, \"angle\" => 24} // 是否存在 key 为 alex 的元素 m1.has('alex'); // true // 删除 key 为 alex 的元素 m1.delete('alex'); // true 8. Set（ES6 规范定义的新的数据类型） Set 和 Map 类似，也是一组 key 的集合，但不存储 value 。由于 key 不能重复，所以，在 Set 中，没有重复的 key。 // 声明一个空 Set let s = new Set(); let s1 = new Set([1, 2, 3, 3, '3', '3', '4']); s1; // Set(5) {1, 2, 3, \"3\", \"4\"} 重复元素会自动被过滤 // 添加元素 s1.add(1); // Set(5) {1, 2, 3, \"3\", \"4\"} 添加重复元素，不会有任何效果 // 删除元素 s1.delete(1); // true s1; // Set(4) {2, 3, \"3\", \"4\"} Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-08 14:11:06 "},"doc/javascript-notes/operation-file.html":{"url":"doc/javascript-notes/operation-file.html","title":"JavaScript 操作文件","keywords":"","body":"JavaScript 操作文件 上传文件的控件为 当一个表单包含此控件时，表单的 enctype 必须指定为 multipart/form-data ， method 必须指定为 post ，浏览器才能发送表单数据，出于安全考虑，浏览器只允许用户点击 来选择本地文件，用 JavaScript 对 的 value 赋值是没有任何效果的。 案例 读取用户选择的图片文件，并在一个 div 中预览图像 let fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener('change', function () { // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) { info.innerHTML = '没有选择文件'; return; } // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '' + '大小: ' + file.size + '' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' && file.type !== 'image/png' && file.type !== 'image/gif') { alert('不是有效的图片文件!'); return; } // 读取文件: let reader = new FileReader(); reader.onload = function(e) { // 当文件读取完成后，自动调用此函数 let data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; }; // 以 DataURL 的形式读取文件: reader.readAsDataURL(file); }); Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-04 14:28:40 "},"doc/javascript-notes/operation-dom.html":{"url":"doc/javascript-notes/operation-dom.html","title":"JavaScript 操作DOM","keywords":"","body":"JavaScript 操作 DOM 取出 DOM 节点 // 返回 id 为 `test` 的节点 let test = document.getElementById('test'); // 先定位 id 为 `test-table` 的节点，再返回其内部所有 tr 节点 let trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位 id 为 `test-div` 的节点，再返回其内部所有 class 包含 red 的节点 let reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点 test 下的所有直属子节点 let cs = test.children; // 获取节点 test 下第一个子节点 let firstCs = test.firstElementChild; // 获取节点 test 下最后一个子节点 let lastCs = test.lastElementChild; // 通过 querySelector 获取 id 为 q1 的节点 let q1 = document.querySelector('#q1'); // 通过 querySelectorAll 获取 q1 节点内的符合条件的所有节点 let ps = q1.querySelectorAll('div.highlighted > p'); 更新 DOM let p = document.getElementById('p-id'); // 设置文本为 ABC p.innerHTML = 'ABC'; // 此时为 ABC // 设置 HTML p.innerHTML = 'ABC RED XYZ'; // 直接将原来的所有子节点给替换掉了 插入 DOM appendChild appendChild 会把一个子节点添加到父节点的最后一个子节点 没更改之前的 html 结构 JavaScript Java Python Scheme let js = document.getElementById('js'), list = document.getElementById('list'); list.appendChild(js); 更改之后的 html 结构 因为我们插入的 js 节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 Java Python Scheme JavaScript 从零开始创建一个新的节点，然后插入到指定位置 let list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 更改之后的 html 结构 Java Python Scheme Haskell 动态添加 css 定义 let d = document.createElement('style'); d.setAttribute('type', 'text/css'); d.innerHTML = 'p { color: red }'; document.getElementsByTagName('head')[0].appendChild(d); insertBefore insertBefore 可以将子节点插入到指定的位置 没更改之前的 html 结构 Java Python Scheme let list = document.getElementById('list'), ref = document.getElementById('python'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); 更改之后的 html 结构 Java Haskell Python Scheme 删除 DOM // 拿到待删除节点 let self = document.getElementById('to-be-removed'); // 拿到父节点 let parent = self.parentElement; // 删除 let removed = parent.removeChild(self); removed === self; // true 当你遍历一个父节点的子节点并进行删除操作时，要注意，children 属性是一个只读属性，并且它在子节点变化时会实时更新。 First Second 循环删除子节点时 let parent = document.getElementById('parent'); parent.removeChild(parent.children[0]); parent.removeChild(parent.children[1]); // 浏览器此时会报错，因为已经删除过一个子节点了，此时没有索引为 1 的节点了，此时，原来索引为 1 的节点的索引已经变成了 0 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-05 21:01:12 "},"doc/javascript-notes/operation-form.html":{"url":"doc/javascript-notes/operation-form.html","title":"JavaScript 操作表单","keywords":"","body":"JavaScript 操作表单 html 表单的输入控件 文本框，用于输入文本。 口令框，用于输入口令。 单选框，用于选择一项。 复选框，用于选择多项。 下拉框，用于多选一。 隐藏文本，用户不可见，但表单提交时会把隐藏文本发送到服务器。 html5 控件 日期控件。 日期时间控件。 颜色选择器控件。 获取值 获取对应用户输入值 let input = document.getElementById('email'); input.value; // 返回用户输入的值 这种方式可以获取 text 、 password 、hidden 和 select 类型的表单，但是要是想获取 radio 或者 select 则需要通过 checked 判断 Monday Tuesday let mon = document.getElementById('monday'); let tue = document.getElementById('tuesday'); mon.value; // \"1\" tue.value; // \"2\" mon.checked; // true 或者 false tue.checked; // true 或者 false 设置值 获取对应用户输入值 let input = document.getElementById('email'); input.value = 'demo@example.com'; // 设置文本框的内容 提交表单 submit() Submit function doSubmitForm() { let form = document.getElementById('test-form'); form.submit(); } onsubmit() Submit function checkForm() { let form = document.getElementById('test-form'); return true; // 返回 true 表示提交表单，返回 false 将不会提交表单 } Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-06 00:54:23 "},"doc/javascript-notes/window-object.html":{"url":"doc/javascript-notes/window-object.html","title":"JavaScript 浏览器对象","keywords":"","body":"浏览器对象 window window 对象不但充当全局作用域，而且表示浏览器窗口 // 内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 window.innerWidth; // 获取浏览器窗口的内部宽度 window.innerHeight; // 获取浏览器窗口的内部高度 window.outerWidth; // 获取浏览器窗口的整个宽度 window.outerHeight; // 获取浏览器窗口的整个高度 navigator navigator 对象表示获取浏览器信息 navigator.appName; // 浏览器名称 navigator.appVersion; // 浏览器版本 navigator.language; // 浏览器设置的语言 navigator.platform; // 操作系统类型 navigator.userAgent; // 浏览器设定的 User-Agent 字符串 screen screen 对象表示屏幕的信息 screen.width; // 屏幕宽度，以像素为单位 screen.height; // 屏幕高度，以像素为单位 screen.colorDepth; // 返回颜色位数，如8、16、24 location location 对象表示当前页面的 url 信息，比如一个完整的 url 为：http://www.example.com:8080/path/index.html?a=1&b=2#TOP // 获取完整的 url location.href; // \"http://www.example.com:8080/path/index.html?a=1&b=2#TOP\" // 获取协议 location.protocol; // \"http\" // 获取主机域名 location.host; // \"www.example.com\" // 获取端口 location.port; // \"8080\" // 获取路径名 location.pathname; // \"/path/index.html\" // 获取 get 参数 location.search; // \"?a=1&b=2\" // 获取 hash 参数 location.hash; // \"TOP\" // 加载一个新页面 location.assign(\"http://www.baidu.com?a=1&b=2\"); // 会跳转到 `http://www.baidu.com?a=1&b=2` 页面中去 // 重新加载当前页面 location.reload(); document document 对象就是整个 DOM 树的根节点 服务器端在设置 Cookie 时，应该始终坚持使用 httpOnly ，从而不让 JavaScript 读取 cookie document.cookie; // 获取当前页面的 Cookie Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-07 20:23:07 "},"doc/javascript-notes/error-handle.html":{"url":"doc/javascript-notes/error-handle.html","title":"JavaScript 错误处理","keywords":"","body":"JavaScript 错误处理 捕获错误的三种形式 // 完整的写法 try { } catch (e) { console.log('出错了：', e); if (e instanceof TypeError) { console.log('类型错误！'); } else if (e instanceof Error) { console.log(e.message); } else { console.log('Error：' + e); } } finally { } // 只有 try ... catch 没有 finally try { } catch (e) { } // 只有 try ... finally 没有 catch try { } finally { } 抛出错误 程序也可以主动抛出一个错误，让执行流程直接跳转到 catch 块。抛出错误使用 throw 语句。 try { throw new Error('随便报错'); } catch (e) { console.log('出错了：' + e); // 出错了：Error: 随便报错 } 异步错误处理 涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行，因此我们需要在回调函数中捕获异常。 自定义异常类 module.exports = class ApiError extends Error { constructor(code, message) { super(); // 未定义错误信息，就默认 500 服务器内部错误 this.code = code || 500 this.message = message || '未定义错误提示信息'; } } Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-09-11 22:48:55 "}}