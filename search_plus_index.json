{"./":{"url":"./","title":"前言","keywords":"","body":" SELECT * FROM LEARNS WHERE LIVE IS NOT NULL 索引 这里只会记录本人的学习笔记，若需要访问本人博客，请 点我 进行访问。 在线访问我的笔记 蒲东平的博客 - 新 蒲东平的博客 - 旧 蒲东平的编程笔记 GiteePages GithubPages 当前笔记目录 Python 系列 python 基础语法 python 的基本数据类型 python 类型判断 python 错误、异常处理、记录日志 python IO 编程 python 函数以及传参 python 模块 python 类与对象 python 高阶函数 python 高级特性 Git 系列 git 相关命令 git bug 分支 git 标签 Docker 系列 docker 常见命令 laradock 笔记 JavaScript 系列 JavaScript 基础语法 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-08 10:11:57 "},"doc/python-notes/basic-grammar.html":{"url":"doc/python-notes/basic-grammar.html","title":"python 基础语法","keywords":"","body":" python 基础语法 python 中只有两种循环方式 for 和 while 可以使用 continue 和 break 关键字 # for 循环 for x in list(range(5)): if n % 2 == 0: # 只取奇数 continue print(x) # while 循环 sum = 0 n = 5 while n > 0: if n input 交互式输入 # input 返回值为 string a_input = input('Please give a number:') if a_input == '1': print('This is a good one') elif a_input == str(2): print('See you next time') else: print('Good luck') 三元表达式 # 条件为真时返回的结果 if 条件判断 else 条件为假时的返回结果 x if x > y else y 用字典映射代替 switch case 语句 ''' 用字典映射代替 switch case 语句 ''' day = 6 def get_sunday(): return 'sunday' def get_monday(): return 'monday' def get_tuesday(): return 'tuesday' def get_default(): return 'Unkown' switcher = { 0 : get_sunday, 1 : get_monday, 2 : get_tuesday } # 调用方法时，需要添加最后一个括号 () day_name = switcher.get(day, get_default)() print(day_name) # Unkown Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:16:49 "},"doc/python-notes/data-type.html":{"url":"doc/python-notes/data-type.html","title":"python 的基本数据类型","keywords":"","body":"Python 的基本数据类型 1. Number：数字（整数、小数） 整数：int 10_000_000_000 和 10000000000 是完全一样的 浮点数：float （ python 默认就已经是双精度了） Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大） 布尔类型：bool （ True 和 False ） and => 逻辑与 or => 逻辑或 not => 逻辑非 复数：complex 其他语言对于浮点数会有：单精度（float）、双精度（double）其他语言对于整数会有：short、int、long 2/2 => 1.0 除法运算会自动转化成浮点数 2//2 => 1 整除（地板除） 1//2 => 0 ， 10 // 3 => 3 10 % 3 => 1 余数运算 2. str：字符串（序列） # 对字符串不转义 print(r'\\\\\\t\\\\') => \\\\\\t\\\\ # 表示多行内容时 print('''line1 line2 line3''') # 只有一个参数时 'Hello, %s' % 'world' => 'hello, world' # 多个参数时 'Hello, %s: your age is %d' % ('alex', 26) => 'Hello, alex: your age is 26' f-string 方式格式化字符串 r = 3.5 s = 3.1415926 print(f'The r is {r} and the s is {s:.2f}') # .2f 表示保留两位小数 The r is 3.5 and the s is 3.14 3. 组（序列） 列表: list （可变化的有序表） list 是一种有序的集合，可以随时添加和删除其中的元素。 # 申明一个空列表 list1 = [] # 或者 list1 = list() # 嵌套列表 list1 = [1, 2, 3, 'hello', 'world', True, False, [5,6,7]] list1[0] => 1 # 取出第一个元素 list1[-1] 或者 list1[(len(list1) -1)] => [5,6,7] # 取出最后一个元素 # 追加元素到末尾 list1.append('alex') # 插入元素到指定位置 list1.insert(3, 'alex') # 删除末尾的元素 list1.pop() # 删除指定位置的元素（索引位置） list1.pop(3) # 更新指定位置元素 list1[3] = 'alex' # 从小到大排序 list1.sort() # 从大到小排序 list1.sort(reverse=True) 元组: tuple （不可变化的有序表：指向不变） tuple 一旦初始化就不能修改。 # 定义一个空 tuple tuple1 = () # 或者 tuple1 = tuple() # 比较特殊的现象 (1) 为 int 类型，是因为：小括号在 python 中表示数学运算优先级，因此定义一个元素的 tuple 时，必须加一个逗号，来消除歧义，python 在显示一个元素的 tuple 时，也会加一个逗号，以免开发人员误解成数学计算意义上的括号 tuple2 = (1,) tuple1 = (1, '-1', True, False) # 也可以这么定义（不加括号） tuple2 = 1, '-1', True, False tuple1[0] => 1 # 取出第一个元素 # 理解 *指向不变* t = ('a', 'b', ['A', 'B']) t[2][0] = 'X' t[2][1] = 'Y' # 以上结果同样成立，因为 t 中的 list 本身是可变的，但是 `t[2][2] = 'Z'` 则会报错，因此，tuple 的每个元素，指向永远不变。 4. set：集合 （不会有重复的值） set 和 dict 的唯一区别仅在于没有存储对应的 value, set 可以看成数学意义上的无序和无重复元素的集合 # 申明一个空的 set s = set() # 提供一个 list 作为输入集合，重复元素会在 set 中自动被过滤掉 s = set([2, 3, 4, 4, 5, 1, 1]) # 放入一个字典作为输入集合 ss = set({1, 2}) s.add(6) # 添加新元素到 set 中 s.add(5) # 重复添加元素到 set 中，可以添加，但是不会有效果 s.remove(4) # 删除元素 s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) # 两个集合的交集 join_s = s1 & s2 # print(join_s) => {2, 3} # 两个集合的并集 union_s = s1 | s2 # print(union_s) => {1, 2, 3, 4} # 两个集合的差集 c_s = s1 - s2 # print(c_s) => {1} c_s1 = s2 -s1 # print(c_s1) => {4} 5. dict：字典 dict 全 称dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。 不允许有重复的 key key 必须为不可变的类型，比如：int、str 特点有： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict 是用空间来换取时间的一种方法。 # 申明一个空的字典 dict1 = {} # 或者 dict1 = dict() dict1 = {'name': 'harry', 'age': 26} # 取出字典中的某个值 name = dict1['name'] # 或者 name = dict1.get('name') # 向字典中增加一个元素 dict1['sex'] = 1 # 修改字典中的某个值 dict1['name'] = 'alex' # 避免 key 不存在的情况，有两种方法 # 1、判断字典中的 key 是否存在，存在时为 True 不存在时为 False a = 'name' in dict1 # 2、直接尝试从字典中取 key 所对应的值，如果不存在则返回 None ，或者可以提供 get 的第二个参数，返回自定义的 value print(dict1.get('name1')) print(dict1.get('name1', 'jack')) # 删除一个 key dict1.pop('name') print(dict1) 6. None 空值 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:36:31 "},"doc/python-notes/type.html":{"url":"doc/python-notes/type.html","title":"python 类型判断","keywords":"","body":"python 类型判断 判断基本数据类型 t1 = type(123) == type(456) print(t1) # True t2 = type(123) == int print(t2) # True t3 = type('a') == type('1') print(t3) # True t4 = type('a') == str print(t4) # True t5 = type(123) == type('123') print(t5) # False t6 = isinstance('a', str) print(t6) # True t7 = isinstance(123, (list, int, str)) print(t7) # True 判断一个对象是否是函数 import types def fn(): pass t1 = type(fn) == types.FunctionType # types 模块中定义的常量 print(t1) # True t2 = type(abs)==types.BuiltinFunctionType print(t2) # True t3 = type(lambda x: x)==types.LambdaType print(t3) # True t4 = type((x for x in range(10)))==types.GeneratorType print(t4) # True Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:25:17 "},"doc/python-notes/handle-err.html":{"url":"doc/python-notes/handle-err.html","title":"python 错误、异常处理、记录日志","keywords":"","body":"python 错误、异常处理、记录日志 异常 import logging try: print('try...') r = 10 / 0 print('result:', r) except ValueError as e: # 所有的错误实例都是从 BaseException 类派生的 print('ValueError:', e) except ZeroDivisionError as e: # print('except:', e) logging.exception(e) # 记录错误信息 # raise => raise 语句如果不带参数，就会把当前错误原样抛出 # raise ValueError('input error!') => 还可以把一种类型的错误转化为另一种类型 else: # 如果没有错误发生时，会自动执行 else 语句。也可以不需要 else 语句 print('no error!') finally: # 不管是否异常，都会执行 finally 模块的代码。可以没有 finally 语句 print('finally...') print('END') # 常用的异常处理如下写法足矣 try: return self[key] except KeyError: raise AttributeError(r\"'Dict' object has no attribute '%s'\" % key) 断言 assert def foo(s): n = int(s) assert n != 0, 'n is zero!' # 断言 n != 0 应该是 True 否则后面的代码肯定会出错，且此时 assert 会抛出 AssertionError 异常 return 10 / n foo('0') 记录日志 logging 日志级别优先级 debug import logging logging.basicConfig( level=logging.INFO, filename='runtime.log', datefmt='%Y-%m-%d %H:%M:%S', format=\"【%(asctime)s %(levelname)s】 %(lineno)d: %(message)s\" ) def foo(s): n = int(s) logging.debug('出错啦！') return 10 / n foo('0') Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:31:13 "},"doc/python-notes/io.html":{"url":"doc/python-notes/io.html","title":"python IO 编程","keywords":"","body":"python IO 编程 文件 IO 官方文档 open 函数 读文件 # 方式1: try: f = open('./runtime.log', 'r') # 文件不存在时，会抛出 IOError 错误 print(f.read()) # 读取文件的全部内容 finally: if f: f.close() # 文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的 # 方式2: # 使用 with 语句来自动调用 close() 方法，使得代码更加简洁，二者其实质性是一样的 with open('./runtime.log', 'r') as f: print(f.read()) # 一次性读取文件的全部内容 print(f.read(10)) # 每次最多读取 10 个字节的内容 print(f.readline()) # 每次读取一行内容 for line in f.readlines(): # 一次性读取所有内容并按行返回一个 list print(line.strip()) # 把末尾的 '\\n' 删掉 读二进制文件 # 读取二进制文件，比如图片、视频等，需要 `rb` 模式打开文件即可 f = open('./aa.jpg', 'rb') print(f.read()) # 返回十六进制表示的字节 字符编码 # 要读取非 utf-8 的文本文件时 f = open('./gbk.txt', 'r', encoding='gbk') print(f.read()) # 如果遇到编码不规范的文件时 f = open('./gbk.txt', 'r', encoding='gbk', errors='ignore') print(f.read()) 写文件 # 方式1: f = open('./runtime.log', 'a') # `w` 覆盖写入、`a` 追加写入、`wb` 写二进制文件 f = open('./runtime.log', 'a', encoding='gbk') # 如果需要写入非 utf-8 编码时 f.write('Hello Alex') f.close() # 必须要关闭文件，只有调用了 close() 方法时，操作系统才保证把没有写入的数据全部写入磁盘 # 方式2: # 不用自己调用 close() 方法关闭文件 with open('./runtime.log', 'w') as f: f.write('Hello Alex') 操作文件和目录 # 查看当前目录的绝对路径 abs_path = os.path.abspath('.') print(abs_path) # /Users/pudongping/glory/codes/python/document-converter # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来 # 路径拼接时，需要通过 os.path.join() 函数来操作，避免不同操作系统的路径分隔符不一致导致出错 new_path = os.path.join(abs_path, 'demodir/abc/cc') print(new_path) # /Users/pudongping/glory/codes/python/document-converter/demodir/abc/cc # 如果只需要创建一个目录时 os.mkdir(new_path) # 创建多层级的目录时 os.makedirs(new_path) # 删除一个目录 os.rmdir(new_path) # 拆分路径 path_split = os.path.split(new_path) # 后一部分总是最后级别的目录或文件名 print(path_split) # ('/Users/pudongping/glory/codes/python/document-converter/demodir/abc', 'cc') runtime_path = os.path.join(abs_path, 'runtime.log') print(runtime_path) # /Users/pudongping/glory/codes/python/document-converter/runtime.log runtime_split = os.path.split(runtime_path) print(runtime_split) # ('/Users/pudongping/glory/codes/python/document-converter', 'runtime.log') # 可以直接得到文件扩展名 runtime_split_text = os.path.splitext(runtime_path) print(runtime_split_text) # ('/Users/pudongping/glory/codes/python/document-converter/runtime', '.log') # 对文件重命名 os.rename(runtime_path, 'runtime1.log') # 复制文件 # 复制文件的函数在 os 模块中不存在 import shutil shutil.copyfile('./runtime1.log', 'runtime.log') # 删除文件 os.remove('./runtime1.log') json 转换 如果需要对类转 json 时，可以参考 json 进阶 import json d = dict(name='alex', age=26, city='Chongqin') # 转换为 json 字符串 json_encode = json.dumps(d) print(json_encode) # {\"name\": \"alex\", \"age\": 26, \"city\": \"Chongqin\"} print(type(json_encode)) # # 对中文序列化时 d = dict(name='张三', age=26, city='Chongqin') json_encode = json.dumps(d, ensure_ascii=False) print(json_encode) # {\"name\": \"张三\", \"age\": 26, \"city\": \"Chongqin\"} # 把 json 反序列化为 python 对象 json_decode = json.loads(json_encode) print(json_decode) # {'name': 'alex', 'age': 26, 'city': 'Chongqin'} print(type(json_decode)) # Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:33:01 "},"doc/python-notes/func.html":{"url":"doc/python-notes/func.html","title":"python 函数以及传参","keywords":"","body":"python 函数以及传参 参数组合时，必须按照： 必选参数、默认参数、可变参数、命名关键字参数、关键字参数的顺序使用 技巧 对于任意函数，都可以使用 func(*args, **kw) 的形式调用 *args 是可变参数，args 接收的是一个 tuple**kw 是关键字参数，kw 接收的是一个 dict def tt(name, age, *, city='Shanghai', job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) args = ('alex', 26) kw = {'city': 'Chongqin', 'job': 'Coder'} tt(*args, **kw) 默认参数 def tt(name, age=18): print(f'the name is {name}') print(f'the age is {age}') tt('alex', 26) # output # the name is alex # the age is 26 多个默认参数时 def tt(name, age=18, gender=1, city='Shanghai'): print(f'the name is {name}') print(f'the age is {age}') print(f'the gender is {gender}') print(f'the city is {city}') tt('alex') tt('alex', 26, 0, 'Hubei') tt('alex', 26, 12, city='Chongqing') tt(city='Hubei', gender=0, name='zhangsan') 可变参数 *（参数的个数不确定） def cacl(numbers): sum = 0 for n in numbers: sum = sum + n return sum # 调用的时候需要先组装成一个 list 或者一个 tuple res = cacl([1, 2, 3]) res = cacl((1, 2, 3)) print(res) # 将参数更改为可变参数 def cacl(*numbers): print(type(numbers)) # 为一个元组 tuple sum = 0 for n in numbers: sum = sum + n return sum # 调用的时候则可以直接传参，不再需要转换成 list 或者 tuple res = cacl(1, 2, 3) print(res) # 如果已经存在了一个 list 或者一个 tuple 时，则只需要将 list 或者 tuple 的元素转变成可变参数传进去即可 numbers = [1, 2, 3] # 或者 numbers = (1, 2, 3) res = cacl(*numbers) print(res) 关键字参数 ** def tt(name, age, **kwargs): print('name: ', name, 'age: ', age, 'keywords: ', kwargs) tt('alex', 26) # name: alex age: 26 keywords: {} tt('alex', 26, city='Shanghai', job='Coder') # name: alex age: 26 keywords: {'city': 'Shanghai', 'job': 'Coder'} extra = {'city': 'Shanghai', 'job': 'Coder'} tt('alex', 26, **extra) # name: alex age: 26 keywords: {'city': 'Shanghai', 'job': 'Coder'} 命名关键字参数 # 只接收 city 和 job 作为关键字参数 def tt(name, age, *, city, job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) tt('alex', 26, job='Coder', city='Shanghai') # 或者设置默认值 def tt(name, age, *, city='Shanghai', job): print('name: ', name, 'age: ', age, 'city: ', city, 'job: ', job) tt('alex', 26, job='Coder') 函数多个返回结果 def demage(skill1, skill2): damage1 = skill1 * 3 damage2 = skill2 * 2 + 10 return damage1,damage2 # 返回结果类型为tuple print(type(demage(1, 2))) # 序列解包的方式接受返回值 skill1_demage, skill2_demage = demage(1, 2) print(skill1_demage, skill2_demage) Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:34:11 "},"doc/python-notes/module.html":{"url":"doc/python-notes/module.html","title":"python 模块","keywords":"","body":"python 模块 官方第三方模块库Anaconda 是基于 Python 的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库 模块 （Module） 一个 .py 文件就是一个 python 模块（Module） 包 （Package） 一个目录就是一个包 每一个包目录下面都会有一个 __init__.py 的文件，这个文件是 必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。 __init__.py 可以是空文件，也可以有Python代码，因为init.py本身就是一个模块，而它的模块名就是文件夹的名称 demo1 ├─ __init__.py ├─ abc.py └─ xyz.py abc.py 的模块名就为 demo1.abc 自己创建模块时要注意命名，不能和 Python 自带的模块名称冲突。例如，系统自带了 sys 模块，自己的模块就不可命名为 sys.py ，否则将无法导入系统自带的 sys 模块。 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在 Python 交互环境执行 import abc ，若成功则说明系统存在此模块 模块的写法 hello.py #!/usr/bin/env python3 # 第 1 行：可以让这个 hello.py 文件直接在 Unix/Linux/Mac 上运行 # -*- coding: utf-8 -*- # 第 2 行：表示 .py 文件本身使用标准 UTF-8 编码 ' a test module ' # 第 4 行： 是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释； __author__ = 'Alex Pu' # 第 6 行： 使用__author__变量把作者写进去 import sys def test(): args = sys.argv # sys模块有一个 argv 变量，用 list 存储了命令行的所有参数。 if len(args)==1: print('Hello, world!') elif len(args)==2: print('Hello, %s!' % args[1]) else: print('Too many arguments!') if __name__=='__main__': test() # 执行代码 # python3 hello.py => Hello, world! # python3 hello.py alex => Hello, alex! 作用域 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的 __author__，__name__ 就是特殊变量，hello 模块定义的文档注释也可以用特殊变量 __doc__ 访问，我们自己的变量一般不要用这种变量名 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的（private），不应该被直接引用，比如 _abc，__abc 等； 但是 python 并没有一种方法可以完全限制访问 private 函数或变量！ import 载入模块 # 方法01、直接载入 import time print(time.localtime()) # 方法02、直接载入并别名 import time as t print(t.localtime()) # 方法03、只载入 time 模块的部分功能 from time import localtime,time print(localtime()) # 方法04、载入 time 模块的全部功能 from time import * print(localtime()) Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:37:54 "},"doc/python-notes/class.html":{"url":"doc/python-notes/class.html","title":"python 类与对象","keywords":"","body":"python 类与对象 类与对象 定义最简单的类 class Student(object): # 类变量 name = 'init name' age = 0 def __init__(self): pass def do_homework(self): pass student1 = Student() student2 = Student() # 打印出对象实例的内存地址 # print(id(student1)) # 1989045387336 # print(id(student2)) # 1989045405384 # __dict__ 保存着当前对象实例下所有的变量 print(student1.__dict__) # {} print(student2.__dict__) # {} 类变量和实例变量 python 会先从对象的实例变量中查找变量，如果找不到，则会从类变量中查找，如果本类中依然找不到类变量，则会从父类中继续去查找 优先级为：对象的实例变量 > 类变量 > 父类类变量 class Student(object): # 类变量只是和类相关联在一起的 name = 'init name' age = 0 # 这里的形参是实例变量，实例变量只是和对象实例关联在一起的 def __init__(self, name1, age1): # self.name 类似于这样的，就是定义并赋值给实例变量（实例变量初始化） self.name = name1 self.age = age1 def do_homework(self): pass student1 = Student('alex', 26) student2 = Student('harry', 25) print(student1.__dict__) # {'name': 'alex', 'age': 26} print(student2.__dict__) # {'name': 'harry', 'age': 25} print(Student.__dict__) # {'__module__': '__main__', 'name': 'init name', 'age': 0, '__init__': , 'do_homework': , '__dict__': , '__weakref__': , '__doc__': None} # 访问实例变量 print(student1.name) # alex print(student2.name) # harry # 访问类变量 print(Student.name) # init name 实例变量和类变量的区别 class Student(object): name = 'alex' # 类属性 s = Student() # 创建实例对象 s # 打印 name 属性，因为实例没有 name 属性，所以会继续查找 class 的 name 属性 print(s.name) # alex # 打印 class 的 name 属性 print(Student.name) # alex # 给实例对象 s 绑定 name 属性 s.name = 'Harry' # 由于实例属性优先级比类属性高，因此，会屏蔽掉 class 的 name 属性 print(s.name) # Harry # 但是 class 属性并没有消失，类属性还是可以访问 print(Student.name) # alex # 删除掉实例对象 s 的属性 del s.name # 由于实例对象 s 的属性没有找到，因此此时会显示出 class 的 name 属性 print(s.name) # alex 使用 slots 限制实例的属性 __slots__ 定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义 __slots__ ，这样，子类实例允许定义的属性就是自身的 __slots__ 加上父类的 __slots__ class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称，不在此 tuple 中的属性将不能通过实例绑定 s = Student() s.name = 'alex' s.age = 26 # 当尝试绑定除了 __slots__ 之外的属性时，会报错 s.city = 'Chongqin' # 会报错 实例方法 class Student(object): # 类变量 all_students = 0 # 这里的 self 可以随便命名，比如说 this、aa、bb 都可以，但是建议命名为 self # self 代表的是实例对象，而不是类 # 构造方法可以看成比较特殊的实例方法 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 实例方法 def cal_all_students(self): print(self.name) # 实例方法中访问实例变量 # 访问类变量 print(Student.all_students) # 实例方法中访问类变量 print(self.__class__.all_students) # 这种方式也可以访问类变量 student1 = Student('alex', 26) student2 = Student('harry', 25) # 访问实例变量 print(student1.name) # alex print(student2.name) # harry # 访问实例方法 student1.cal_all_students() 类方法 class Student(object): # 类变量 all_students = 0 # 构造方法可以看成比较特殊的实例方法 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 类方法：用于操作和类相关的变量 @classmethod def cal_all_students(cls): # 类方法中不可以调用实例变量 # print(cls.name) # 会报错，因为此时实例还未创建 cls.all_students += 1 print('当前所有的学生人数为：%s' % cls.all_students) student1 = Student('alex', 26) # 访问类方法 Student.cal_all_students() # 当前所有的学生人数为：1 # 也可以通过实例对象去访问类方法，但是不建议这么去操作，因为不符合逻辑 # student1.cal_all_students() student2 = Student('harry', 25) Student.cal_all_students() # 当前所有的学生人数为：2 类方法和实例方法的比较：实例方法关联实例对象本身，类方法关联类本身。操作和对象无关的方法还是建议使用类方法（约定俗成） 静态方法（不常用，也不是很建议用） class Student(object): # 类变量 all_students = 0 def __init__(self, name1, age1): self.name = name1 self.age = age1 # 静态方法：不经常用，当你自己觉得这个方法与类或者对象没有关联的时候可以使用，但是原则性来说，不要经常用 @staticmethod def add(x, y): s = x + y # 静态方法中不可以访问实例变量 # print(self.name) 会报错，因为没有 self print('静态方法中访问类变量： all_students 为 => %s' % Student.all_students) print('x + y 的结果为： %d' % s) student1 = Student('alex', 26) # 调用静态方法 student1.add(1, 2) # x + y 的结果为： 3 Student.add(3, 4) # x + y 的结果为： 7 私有类变量 类的私有变量 private 通过给属性的名称前加上两个下划线 __ 实现。这样的变量外部实例是无法访问的，因为实质性是把改属性的名称改成了 _类名__属性名 class Student(object): def __init__(self): self.__name = 'alex' self.age = 26 def tt(self): pass print(Student().__name) # 会直接报错，没有 __name 属性 print(Student()._Student__name) # alex 获取对象的属性或属性方法 print(dir(Student)) # 罗列出一个对象的所有属性和方法 # 判断是否有 age 属性 print(hasattr(Student(), 'age')) # True print(hasattr(Student(), '__name')) # False 这里为 False ，是因为 __name 属性定义为 private 属性，被 python 改名为 _Student__name print(hasattr(Student(), '_Student__name')) # True # 设置属性 obj = Student() setattr(obj, 'gender', 1) print(hasattr(obj, 'gender')) # True # 获取属性 print(getattr(obj, 'gender')) # 1 # 属性不存在时，设置一个默认值 print(getattr(obj, 'city', 'Shanghai')) # Shanghai print(getattr(obj, 'gender', 100)) # 1 # 判断是否有 tt 属性方法 print(hasattr(obj, 'tt')) # True fn = getattr(obj, 'tt') # 获取类方法 tt，并赋值给变量 fn，调用 fn() 和 tt() 是一样的效果 子类继承父类 ./c2.py class Human(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) def do_homework(self): print('This is parent do_homework') ./c1.py from c2 import Human # 继承了 Human 父类 class Student(Human): def __init__(self, school, name, age): self.school = school # 子类调用父类的构造函数 super(Student, self).__init__(name, age) def do_homework(self): # 子类调用父类的同名方法 super(Student, self).do_homework() print('english homework') student1 = Student('半月小学', '小石头', 18) # 子类和父类都有同名方法，那么会优先返回子类结果 student1.do_homework() 枚举类 简单枚举，使用默认值 from enum import Enum Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')) # 可以直接使用 Month.Jan 来引用一个常量 print(Month.Jan) # Month.Jan # 枚举所有成员 for name, member in Month.__members__.items(): # the name is => [Jan] and the member is => [Month.Jan] and the member default value is => [1] # value 属性则是自动赋给成员的 int 常量，默认从 1 开始计数 print(f'the name is => [{name}] and the member is => [{member}] and the member default value is => [{member.value}]') 自定义修改枚举值 from enum import Enum, IntEnum, unique # @unique 装饰器可以检查保证没有重复值 # IntEnum 可以限制枚举值必须为数字类型 @unique class Weekday(IntEnum): Sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 day1 = Weekday.Mon print(day1) # Weekday.Mon print(Weekday.Mon) # Weekday.Mon print(Weekday['Mon']) # Weekday.Mon print(day1 == Weekday.Mon) # True print(day1 == Weekday.Tue) # False print(Weekday(1)) # Weekday.Mon print(day1 == Weekday(1)) # True # 获取枚举值 print(Weekday.Mon.value) # 1 # 获取枚举标签的名称 print(Weekday.Mon.name) # Mon # 枚举类型转换 # 以枚举值去找枚举类型 print(Weekday(3)) # Weekday.Wed Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:39:15 "},"doc/python-notes/high-func.html":{"url":"doc/python-notes/high-func.html","title":"python 高阶函数","keywords":"","body":"python 高阶函数 map map() 函数接收两个参数，一个是函数，一个是 Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。 # 把这个 list 所有数字转为字符串 l = list(map(str, [1, 2, 3, 4])) print(l) # ['1', '2', '3', '4'] reduce reduce 把一个函数作用在一个序列 [x1, x2, x3, ...] 上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 自己实现字符串转整型的方法 from functools import reduce DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9} def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) print(str2int('139')) # 139 filter filter 用于过滤序列，和 map() 类似，filter() 也接收一个函数和一个序列。和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素。 过滤序列中的空字符串 def not_empty(s): return s and s.strip() l = list(filter(not_empty, ['A', '', 'B', None, 'C', ' '])) print(l) # ['A', 'B', 'C'] sorted sorted 可以对 list 进行排序，还可以接收一个 key 函数来实现自定义的排序。 l = sorted([36, 5, -12, 9, -21]) print(l) # [-21, -12, 5, 9, 36] # 根据绝对值做排序 l1 = sorted([36, 5, -12, 9, -21], key=abs) print(l1) # [5, 9, -12, -21, 36] zip zip 可以将两个 list 中的每一个元素进行合并。 l1 = [1, 2, 3, 88] l2 = [4, 5, 6] r1 = list(zip(l1, l2)) print(r1) # [(1, 4), (2, 5), (3, 6)] r2 = l1 + l2 print(r2) # [1, 2, 3, 88, 4, 5, 6] copy 和 deepcopy copy 只会复制父对象，子对象是公用的，deepcopy 会完全复制父对象和子对象 import copy a = [1,2,3,[5,6,7]] b = a # id为硬盘空间索引 print(id(a) == id(b)) # True # 浅复制 c = copy.copy(a) print(id(a) == id(c)) # False,说明 a和c不是同样的东西 d = copy.copy(a) print(id(a[1]) == id(d[1])) # True,说明子对象是相同的东西 a[1] = 555 print(a,d) # a => [1, 555, 3, [5, 6, 7]], b => [1, 2, 3, [5, 6, 7]] a[3][1] = 666 print(a,d) # a => [1, 555, 3, [5, 666, 7]], b => [1, 2, 3, [5, 666, 7]] # 深复制 import copy a = [1,2,3,[5,6,7]] b = copy.deepcopy(a) print(id(a)==id(b)) # False 完全是不一样的东西 函数作为返回值 （闭包函数） # 这里就是一个闭包函数 # 不需要立即求和时（懒计算） def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum # 返回的并不是求和结果，而是求和函数 f = lazy_sum(1, 3, 5, 7) # 调用函数时才会真正计算求和的结果 print(f()) # 16 # 当我们调用 lazy_sum() 时，每次调用都会返回一个新的函数，即使传入相同的参数 f1 = lazy_sum(1, 3, 5, 7) f2 = lazy_sum(1, 3, 5, 7) print(f1 == f2) # False 简单闭包（闭包 = 函数 + 环境变量） # 闭包 = 函数 + 环境变量 def curve_pre(): a = 25 def curve(x): return a*x*x return curve a = 10 f = curve_pre() print(f(2)) 对闭包理解容易犯错点 # 错误示例 # def f1(): # a = 10 # def f2(): # # a 被 python 认为是一个局部变量 # c = 20 # return f2 # f = f1() # ''' # 此时 f2 并不能是一个闭包 # ''' # print(f) # print(f.__closure__) def f1(): a = 10 def f2(): # 必须要引用外部的 a 变量，而不是重新给 a 变量赋值 c = 20 * a return f2 f = f1() ''' 此时 f2 就是一个闭包函数 ''' print(f) print(f.__closure__) 让变量可以临时保存 origin = 0 def factory(pos): def go(step): # 强制标注不是本地的局部变量 nonlocal pos new_pos = pos + step pos = new_pos return new_pos return go tourist = factory(origin) # 2 print(tourist(2)) # 5 print(tourist(3)) # 10 print(tourist(5)) 匿名函数 lambda 匿名函数有个限制，就是只能有一个表达式，不用写 return，返回值就是该表达式的结果 l1 = list(map(lambda x: x * x, [1, 2, 3, 4])) print(l1) # [1, 4, 9, 16] # 匿名函数 lambda x: x * x 实际上就是 def f(x): return x * x # 关键字 lamdba 表示匿名函数，冒号前面的 x 表示函数参数 # 还可以将匿名函数赋值给一个变量，再利用变量来调改函数 f = lambda x: x * x print(f(5)) # 25 装饰器 decorator 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 定义装饰器 import time def decorator(func): def wrapper(): print(time.time()) func() return wrapper # 定义装饰器 这里的 [decorator] 和 上面的 def decorator 名称必须是一致的 @decorator def f1(): print('This is a function') # 调用方式没有改变 f1() 当调用装饰器中方法有多个且每个方法参数数量不一致时 import time def decorator(func): def wrapper(*args): print(time.time()) func(*args) return wrapper @decorator def f1(func_name): print('This is a function named ' + func_name) @decorator def f2(func_name1, func_name2): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) f1('cc') f2('cc1', 'cc2') 当调用装饰器中方法有指定参数时 import time def decorator(func): def wrapper(*args, **kw): print(time.time()) func(*args, **kw) return wrapper @decorator def f1(func_name): print('This is a function named ' + func_name) @decorator def f2(func_name1, func_name2): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) @decorator def f3(func_name1, func_name2, **keyword): print('This is a function named ' + func_name1) print('This is a function named ' + func_name2) print(keyword) f1('cc') f2('cc1', 'cc2') f3('cc1', 'cc2', a=1, b=2, c='1,2,3') Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:41:02 "},"doc/python-notes/high-features.html":{"url":"doc/python-notes/high-features.html","title":"python 高级特性","keywords":"","body":"python 高级特性 切片 l = list(range(100)) l1 = l[0:3] # 取前三个数 # print(l1) # [0, 1, 2] l2 = l[:3] # 如果第一个索引是 0 ，还可以这么取前三个数 # print(l2) # [0, 1, 2] l3 = l[2:5] # 从索引 2 开始取值取 (5-2=3) 个元素出来 # print(l3) # [2, 3, 4] l4 = l[-10:] # 取后十个数 # print(l4) # [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] l5 = l[:10:2] # 取前 10 个数，每隔 2 个取一个数 # print(l5) # [0, 2, 4, 6, 8] l6 = l[::10] # 所有的数，每隔 10 个取一个数 # print(l6) # [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] l7 = l[:] # 什么都不写，则原样复制一个 list # print(l7) # [0, 1, 2, 3, ……, 97, 98, 99] 迭代 如果给定一个 list 或 tuple，我们可以通过 for 循环来遍历这个 list 或 tuple ，这种遍历我们称为迭代（Iteration）。只要作用于一个可迭代对象，for 循环就可以正常运行。 d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5} # 只迭代 key 时 for key in d: print(key) # a b c d e # 只迭代 value 时 for value in d.values(): print(value) # 1 2 3 4 5 # 同时迭代 key 和 value 时 for k,v in d.items(): print(f'the key is {k} and the value is {v}') # output # the key is a and the value is 1 # the key is b and the value is 2 # the key is c and the value is 3 # the key is d and the value is 4 # the key is e and the value is 5 # 如果是 list 的话，需要同时迭代索引和元素本身时 l = ['a', 'b', 'c', 'd'] for i, value in enumerate(l): print(i, value) # output # 0 a # 1 b # 2 c # 3 d 如何判断一个对象是否为可迭代的对象？ from collections.abc import Iterable a = isinstance([], Iterable) # True b = isinstance({}, Iterable) # True c = isinstance('abc', Iterable) # True d = isinstance((x for x in range(10)), Iterable) # True e = isinstance(50, Iterable) # False 列表生成式 （支持：列表、元组、集合、字典） 是 Python 内置的非常简单却强大的可以用来创建 list 的生成式 l = [x * x for x in range(1, 11)] print(l) # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] # 生成全排列 l1 = [m + n for m in 'ABC' for n in 'XYZ'] print(l1) # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] # for 后面的 if 是过滤条件，不能加 else l = [x for x in range(1, 11) if x % 2 == 0] print(l) # [2, 4, 6, 8, 10] # for 前面的 if else 是表达式，必须要加 else l1 = [x if x % 2 == 0 else -x for x in range(1, 11)] print(l1) # [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-06 23:42:46 "},"doc/git-notes/command.html":{"url":"doc/git-notes/command.html","title":"git 相关命令","keywords":"","body":"git 相关命令 生成 SSH Key ssh-keygen -t rsa -C \"youremail@xxx.com\" // 输入之后直接两次回车即可 查看 git 用户名和邮箱地址 // 查看用户名 git config user.name // 查看邮箱地址 git config user.email // 查看配置信息 git config --list // git config --global 当前用户全局 // git config --system 当前系统全局 // 修改用户名 git config --global user.name \"username\" // 修改邮箱地址 git config --global user.email \"email\" // 重新输入账号密码 git config --system --unset credential.helper // git config --list 或者 git config -l 查看 git 配置信息 初始化一个 git 仓库 git init 添加文件到 git 仓库 1. 添加文件到缓存区 git add // 比如添加 file.txt 文件： git add file.txt 2. 将缓存区文件提交到本地仓库 git commit -m \"add_file_message\" // 比如提交 file.txt 文件：git commit -m \"add file.txt\" 查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变） git diff // 还可以查看具体哪个文件做了什么修改 // 比如查看 readme.txt 做了什么修改 git diff HEAD -- readme.txt 查看当前仓库状态，任何时候都可以使用 git status 查看提交日志 // 查看全部 git log // 查看最后一次提交 git show // 查看倒数5条 git log -5 // 简化日志显示方式，并含有提交版本号 git log --pretty=oneline 比如： $ git log --pretty=oneline 44c9beb4c58543b89181829755be2c5e9781ba28 (HEAD -> master) append GPL 03112bdf101655c30df9b61e4bd325b2cbe3c090 add distributed 8a1386bd0fe677bca99d5a4ef26e87772a3eca71 wrote a readme file 别名 Alias git config --global alias.br \"branch\" # 创建/查看本地分支 git config --global alias.co \"checkout\" # 切换分支 git config --global alias.cb \"checkout -b\" # 创建并切换到新分支 git config --global alias.cm \"commit -m\" # 提交 git config --global alias.st \"status\" # 查看状态 git config --global alias.pullm \"pull origin master\" # 拉取分支 git config --global alias.pushm \"push origin master\" # 提交分支 git config --global alias.log \"log --oneline --graph --decorate --color=always\" # 单行、分颜色显示记录 git config --global alias.logg \"log --graph --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative\" # 复杂显示 git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 回退版本 // 回退当前版本的上一个版本 git reset --hard HEAD^ // 回退当前版本的上三个版本 git reset --hard HEAD^^^ // 回退当前版本的上100个版本 git reset --hard HEAD~100 // 回退指定版本，并将 「回退」动作作为一个版本提交 git revert 回退指定版本（多半是因为回退版本回退多了） git reset --hard 版本号前几位 // 比如回退到 以上查看日志中的 add distributed 这个提交版本 git reset --hard 44c9beb4c 查看提交版本号 commit id // 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 git reflog 撤销修改 1. 修改只在工作区，还没有添加到缓存区 （还没有 git add） git checkout -- filename // 比如 readme.txt 文件只是在工作区修改了，想回退到修改之前的提交的版本 git checkout -- readme.txt 2. 修改从工作区已经提交到了缓存区 （已经 git add） // 将缓存区的修改回退到工作区 git reset HEAD filename // 比如 readme.txt 文件的修改已经提交到缓存区了，但是想撤销修改分为两步 01.将缓存区的修改回退到工作区 git reset HEAD readme.txt 02.将在工作区的修改回退到和上一个版本一样 git checkout -- readme.txt 3. 修改已经从缓存区提交到了本地仓库 （已经 git commit） // 回退当前版本的上一个版本 git reset --hard HEAD^ 4. 将在暂存区的更改文件进行强制撤销。（想让之前已经提交到缓存区的文件覆盖工作区的文件） git checkout -f 5. 命令 git clean 作用是清理项目，-f 是强制清理文件的设置，-d 选项命令连文件夹一并清除 git clean -f -d 6. 假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： git fetch origin git reset --hard origin/master 删除文件 1. 确实要删除该文件 // 比如以 test.txt 为例子 // 01 本地手动删除 test.txt 文件 rm test.txt 或者 rm -rf test.txt // 02 添加被删除的状态缓存区 git rm test.txt 或者 git add test.txt // 03 提交状态到本地仓库 git commit -m \"remove test.txt\" 2. 工作区误删了文件 // 01 工作区误删了 test.txt 文件 rm test.txt // 02 找回被误删的文件（撤销修改） git checkout -- test.txt // 用版本库中的版本替换掉工作区的版本 创建分支并切换到该分支 git checkout -b alex 或者 git switch -c alex //创建 alex 分支并切换到 alex 分支 //等同于以下两个命令 git branch alex // 创建 alex 分支 git checkout alex 或者 git switch alex // 切换到 alex 分支 合并指定分支到当前分支 // 比如当前位于 master 分支，欲将 alex 分支合并到 master 分支 git merge alex // 如果有冲突，解决步骤如下： 01 先查看冲突文件 git status 02 手动解决冲突文件 03 再次合并分支 git merge alex 04 添加修改到缓存区 git add . 05 提交到本地仓库 git commit -m \"merge fixed\" 查看分支的合并情况 git log --graph --pretty=oneline --abbrev-commit 或者直接使用 git log --graph 命令可以看到分支合并图。 // 设置别名查看所有的提交记录 git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 删除分支 // 合并代码之后删除分支 git branch -d 分支名 // 没有合并代码删除分支 git branch -D 分支名 // 删除远程分支（本地分支需要再次手动删除） git push origin -d 分支名 // 比如删除 alex 分支 git branch -d alex // 删除远程 alex 分支 git push origin -d alex 查看分支 // 只查看远程分支 git branch -r // 只查看本地分支 git branch // 查看所有远程分支和本地分支 git branch -a 拉取远程分支并创建同名本地分支 // 方法一（此方法建立的本地分支和远程分支会有映射关系） git checkout -b [本地分支名] origin/[远程分支名] 举例：git checkout -b alex origin/alex // 方法二（此方法建立的本地分支和远程分支没有映射关系） git fetch origin [远程分支名]:[本地分支名] 举例：git fetch origin alex:alex 查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现） git branch -vv 手动建立本地分支和远程分支的映射关系 git branch -u origin/[分支名] 或者 git branch --set-upstream-to origin/[分支名] 或者 git branch --set-upstream-to=origin/[远程分支名] [本地分支名] 推送分支 git push -u origin // 第一次推送的时候添加 -u 参数，给本地分支和远程分支创建连接关系，当第二次再次推送时，则不需要添加 -u 参数 比如：推送 dev 分支 git push origin dev 查看远程库的信息 git remote // 查看远程库更加详细的信息 // 这里可以看到抓取和推送的 origin 的地址 git remote -v （小写的v） // 删除远程库连接 git remote rm // eg：删除远程 origin 连接 git remote rm origin // 添加远程库连接 git remote add // eg: 关联本人 GitHub 连接，并连接名为 myGitHub git remote add myGitHub git@github.com:Alex66668888/demo.git 多处备份 一个 pull + 多个 push # 添加远程连接 $ git remote add origin git@gitee.com:pudongping/tt.git # 查看远程连接地址，可以看到只有一个 fetch 地址和一个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) # 添加 github 推送地址 $ git remote set-url --add origin git@github.com:pudongping/tt.git # 查看远程连接地址，可以看到只有一个 fetch 地址和两个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) origin git@github.com:pudongping/tt.git (push) # 添加 gitlab 推送地址 $ git remote set-url --add origin git@gitlab.com:pudongping/t1.git # 查看远程连接地址，可以看到只有一个 fetch 地址和三个 push 地址 $ git remote -v origin git@gitee.com:pudongping/tt.git (fetch) origin git@gitee.com:pudongping/tt.git (push) origin git@github.com:pudongping/t1.git (push) origin git@gitlab.com:pudongping/tt.git (push) # 推送到远程分支，就可以看到已经同步到多个平台上去了，一次 push 到多个远程仓库 git push git add 三种状态命令比较 命令 说明 git add . 提交所有修改的和新建的数据暂存区 (提交当前文件夹下所有修改) git add -u 提交所有被删除和修改的文件到数据暂存区（等同于git add -update） git add -A 提交所有被删除、被替换、被修改和新增的文件到数据暂存区（等同于git add –all） 已经推送（push）过的文件，想从 git 远程库中删除，并在以后的提交中忽略，但是却还想在本地保留这个文件 git rm --cached [file-path] git rm --cached config/pay.php # 如果是目录的话，则需要 git rm -r --cached [dir_name] git push 已经推送（push）过的文件，想在以后的提交时忽略此文件，即使本地已经修改过，而且不删除 git 远程库中相应的文件 # 只对文件有效 git update-index --assume-unchanged [file-path] git update-index --assume-unchanged config/pay.php # 如果需要恢复提交 git update-index --no-assume-unchanged [file-path] 合并一个分支上的修改到当前分支 # 比如说 test1 分支上有一个提交 512d725 现在想将这个提交合并到 test2 分支上 # 先切换到 test2 分支上 git checkout test2 # 择优挑选（此时还是在 test2 分支上） git cherry-pick 512d725 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:48:03 "},"doc/git-notes/branch-bug.html":{"url":"doc/git-notes/branch-bug.html","title":"git bug 分支","keywords":"","body":"bug 分支 修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场 git stash 一下，然后去修复 bug，修复后，再 git stash pop，回到工作现场；在 master 分支上修复的 bug，想要合并到当前 dev 分支，可以用 git cherry-pick 命令，把 bug 提交的修改“复制”到当前分支，避免重复劳动。 应用场景如下：当你需要修改一个 bug，但是你当前的开发功能还不想提交到远程版本库中，又必须要先将 bug 提交。 查看当前工作区的状态（假设当前在 dev 分支） // 工作区的文件还没有提交 git status 存储当前的工作现场 git stash 再次查看工作区的状态，应该是干净的 如果需要在 master 分支上修复 bug，那么就需要从 master 分支上创建临时分支 // 切换到 master 分支 git checkout master // 创建修复 bug 的分支为 issue-1 git checkout -b issue-1 在 issue-1 分支上修复 bug 在 issue-1 分支上提交代码 git add -A && git commit -m 'fixed bug 1' 切换到 master 分支 git switch master 从 master 分支上合并 issue-1 分支的代码，并添加了合并信息 git merge --no-ff -m \"merged bug fix 1\" issue-1 原来是在 dev 分支上干活，现在切换到 dev 分支上继续干活 git checkout dev // 如果此时用 git status 命令查看的话，此时的工作区是干净的 查看之前临时存储的工作现场 git stash list 恢复工作现场（有两种方法） // 第一种方法： // 恢复工作现场 git stash apply // 删除之前临时存储的工作现场 git stash drop // 第二种方法： // 恢复的同时把 stash 内容也删了 git stash pop 如果需要恢复指定的工作现场 // 查看所有的工作现场 git stash list // 恢复名称为 「stash@{0}」 的工作现场 git stash apply stash@{0} 将修复好的 bug 同步到其他的分支 可以通过直接将修复 bug 的文件修改内容复制到其他分支，比如在 issue-1 分支上修复的提交版本号为 c55ae16d5b1a，现在只需要将这个版本号的所有修改内容复制到 dev 分支上即可。 // 当前分支为 dev git checkout dev // 复制一个特定的提交到当前分支（此操作会自动提交一个版本号） git cherry-pick c55ae16d5b1a Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:51:22 "},"doc/git-notes/tags.html":{"url":"doc/git-notes/tags.html","title":"git 标签","keywords":"","body":"Git 标签 标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。 创建标签 // 给当前提交版本打标签 git tag // eg: 打一个名称为 v1.0 的标签，此时默认将标签打到最新提交的 commit 上 git tag v1.0 给指定提交版本打标签 // 查看历史提交的 commit id git log --pretty=oneline --abbrev-commit // 给指定提交版本打标签 git tag // eg: 给提交版本号为 c53b867 的版本，打一个名称为 v0.8 的标签 git tag v0.8 c53b867 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字： git tag -a -m // eg：给版本号为 c53b867 的版本，打一个名称为 v0.8 的标签，并对 v0.8 这个标签添加说明文字为 \"add v0.8 tag\" git tag -a v0.8 -m \"add v0.8 tag\" c53b867 查看所有的标签 （标签不是按时间顺序列出，而是按字母排序的。） git tag 查看标签信息 git show // eg：查看标签名得 v0.9 的标签信息 git show v0.9 删除标签 git tag -d // eg：删除标签名为 v0.1 的标签 git tag -d v0.1 推送本地标签到远程库 git push origin // eg： 推送本地标签名为 v0.1 的标签到远程库中 git push origin v0.1 一次性推送全部尚未推送到远程的本地标签 git push origin --tags 如果标签已经推送到远程，想要删除远程标签 // 第一步：删除本地标签 git tag -d v0.1 // 第二步：从远程删除 git push origin :refs/tags/v0.1 // 第三步：在远程库中查看是否被删除 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:20:59 "},"doc/docker-notes/command.html":{"url":"doc/docker-notes/command.html","title":"docker 常见命令","keywords":"","body":"docker 常见命令 查看版本 docker -v 查看详细版本 docker version 查看 docker 基本信息 docker info 镜像相关的命令 镜像仓库地址：https://hub.docker.com 查看本地已经安装的镜像 docker images 搜索指定镜像 docker search # 比如搜索 centos 镜像 docker search centos 拉取镜像 docker pull # 比如拉取 centos 镜像（将会拉取最新版本的镜像，即 latest 版本） docker pull centos # 拉取指定版本的镜像 docker pull ubuntu:16.04 删除镜像 docker rmi # 比如删除 centos 镜像 docker rmi centos 删除所有的镜像 docker rmi $(docker images -q) # 查看所有镜像的镜像 id docker images -q 更新镜像 # 更新镜像前，需要使用镜像创建一个容器 docker run -it ubuntu:15.10 bash # 在运行的容器内部使用 apt-get update 更新 # 更新完毕之后，输入 exit 命令退出容器 # 使用 docker commit 来提交容器副本 docker commit -m=\"has update\" -a=\"alex\" e218edb10161 alex/ubuntu:v2 # -m 表示提交的描述信息 # -a 表示提交的镜像作者 # e218edb10161 表示容器的 id # alex/ubuntu:v2 表示指定要创建的目标镜像名 # 查看新的镜像 docker images # 使用新镜像 alex/ubuntu:v2 来启动一个容器 docker run -it alex/ubuntu:v2 bash 构建镜像 vim ~/glory/codes/book/demo/Dockerfile 填充以下内容，构建一个 centos 8 系统 # 指定使用哪个镜像源 FROM centos:8 # 如果写了 3 次 RUN 那么将会在 docker 上新建 3 层，会导致镜像膨胀过大，下面这种方式只会创建 1 层镜像 RUN /bin/echo 'root:123456' | chpasswd; \\ useradd alex; \\ /bin/echo 'alex:123456' | chpasswd; \\ /bin/echo -e \"LANG=\\\"en_US.UTF-8\\\"\" > /etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D 开始构建镜像，注意不要在 ~/glory/codes/book/demo 目录下放无用的文件，因为会打包所有该目录下的文件然后发送给 docker 引擎，如果文件过多会造成 build 过程缓慢 # -t 表示指定要创建的目标镜像名 # ~/glory/codes/book/demo 表示 Dockerfile 文件所在的目录 docker build -t alex/centos:8.0 ~/glory/codes/book/demo # 查看已经构建好的镜像信息 docker images # 使用新的镜像来创建新容器 docker run -it alex/centos:8.0 bash 设置镜像标签 # 先查看镜像 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alex/centos 8.0 594ab4747ed4 14 minutes ago 210MB # 设置镜像标签 $ docker tag 594ab4747ed4 alex1/centos1:8.1.1 # 再次查看镜像信息会多一个标签 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alex/centos 8.0 594ab4747ed4 14 minutes ago 210MB alex1/centos1 8.1.1 594ab4747ed4 14 minutes ago 210MB 容器相关的命令 查看容器的系统版本信息 # 进入容器后执行 cat /proc/version # 比如会输出以下内容 Linux version 4.19.121-linuxkit (root@18b3f92ade35) (gcc version 9.2.0 (Alpine 9.2.0)) #1 SMP Thu Jan 21 15:36:34 UTC 2021 查看所有的容器 docker ps -a # 或者使用以下命令，是一样的效果 docker container ls -a # 查看最后一次创建的容器 docker ps -l 查看所有已经运行的容器 docker ps 查看容器端口映射 docker port 查看 docker 底层信息（比如：查看指定容器的 ip 地址） # 查看 docker 容器的配置和状态信息 docker inspect # 查看容器的 ip 地址 docker inspect | grep IPAddress # 比如查看容器 id 为 66204be9fe65 的容器所对应的 ip 地址 docker inspect 66204be9fe65 | grep IPAddress # 比如查看容器名称为 alex 所对应的 ip 地址 docker inspect alex | grep IPAddress 创建容器并把镜像恢复到容器当中，且启动容器 docker run [-i][-t][-v][--name][-d][-p] # -i 表示 interactive 交互式 # -t 表示得到一个 terminal # --name 表示修改容器名称 # -d 表示以守护进程的方式运行（默认不会进入容器，想要进入容器则需要使用 docker exec 命令） # -p 表示 **指定** 映射端口 # -P （大写的字母 p ） 表示 **随机** 映射端口 # /bin/bash 和 bash 等效 docker run -it /bin/bash # 比如创建一个新容器并且进入 ubuntu:16.04 镜像 docker run -it ubuntu:16.04 bash # 或者 docker run -it ubuntu:16.04 /bin/bash # 或者 docker run -it ubuntu:16.04 # 以 centos 镜像创建一个新容器，并修改新容器名称为 alex-container docker run -it --name alex-container centos bash # 以守护进程的方式运行 （后台运行） docker run -d --name alex-container centos # 或者 docker run -di --name alex-container centos # 指定容器绑定的网络地址，这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口（默认绑定的都是 tcp 端口） docker run -d -p 127.0.0.1:5001:5000 centos:8.0 bash # 如果需要绑定 udp 端口，则 # （还可以进入容器就直接执行 python app.py 命令） docker run -d -p 127.0.0.1:5001:5000/udp centos:8.0 python app.py # 比如，安装 hyperf 镜像并启动容器 # 如果 docker 启动时开启了 selinux-enabled 选项，容器内访问宿主机资源就会受限，所以启动容器时可以增加 --privileged -u root 选项 docker run --name hyperf \\ -v /workspace/skeleton:/data/project \\ -p 9501:9501 -it \\ --privileged -u root \\ --entrypoint /bin/sh \\ hyperf/hyperf:7.4-alpine-v3.11-swoole 启动容器 docker start # 比如启动容器名称为 redis-alex 的容器 docker start redis-alex # 比如启动容器 id 为 c8c0c770ac5b 的容器 docker start c8c0c770ac5b 直接进入已经创建的容器（不会启动容器） docker start -i # 比如进入容器 id 为 66204be9fe65 的容器 docker start -i 66204be9fe65 # 比如进入容器名称为 alex 的容器 docker start -i alex 重启容器 docker restart # 比如重启容器名称为 redis-alex 的容器 docker restart redis-alex # 比如重启容器 id 为 c8c0c770ac5b 的容器 docker restart c8c0c770ac5b 进入已经运行中的容器 docker exec -it bash # 比如进入容器名称为 redis-alex 的容器 docker exec -it redis-alex bash # 比如进入容器 id 为 c8c0c770ac5b 的容器 docker exec -it c8c0c770ac5b bash # 进入容器之后执行 shell 命令或者执行 shell 脚本 docker exec -it /bin/sh -c \"while true; do echo hello world; sleep 1; done\" # 比如进入容器 id 为 c8c0c770ac5b 的容器，并且进入容器后执行 `bash /portal_api_dfo_hyperf/server.sh restart` 脚本 docker exec -it c8c0c770ac5b /bin/sh -c \"bash /portal_api_dfo_hyperf/server.sh restart\" 停止容器 docker stop # 比如停止容器名称为 redis-alex 的容器 docker stop redis-alex # 比如停止容器 id 为 c8c0c770ac5b 的容器 docker stop c8c0c770ac5b 退出容器 exit 删除容器 docker rm # 也可以加入 -f 参数，强制移除正在运行中的容器 docker rm -f 1e560fca3906 # 清理掉所有处于终止状态的容器 docker container prune 修改容器名称 docker rename # 比如将容器 redis-alex 改名为 redis-tt docker rename redis-alex redis-tt 查看容器的标准输出 docker logs # 比如查看容器 id 为 c8c0c770ac5b 的容器标准输出内容 docker logs c8c0c770ac5b # 也可以加入 -f 参数，像使用 tail -f 一样来输出容器内部的标准输出 docker logs -f c8c0c770ac5b 容器与宿主机之间的文件或者目录拷贝 从宿主机拷贝文件到容器中 docker cp : # 比如将宿主机中的 /home/alex/test.txt 文件拷贝到 centos1 容器中的 /test.txt docker cp /home/alex/test.txt centos1:/test.txt 从容器拷贝到宿主机中 docker cp : # 比如将 centos1 容器中的 /test 目录拷贝到宿主机的 /home/alex 目录下 docker cp centos1:/test /home/alex 目录挂载（创建容器的时候就需要进行目录挂载） docker run -di -v : # 在 windows 下挂载（注意路径的书写方式） # 比如以 centos 镜像创建一个容器，并将本地 D 盘中的 alex 目录，挂载到容器中的 /usr/local/demo 目录 docker run -di -v d:\\alex:/usr/local/demo centos # 在 linux 下挂载 # 比如以 centos 镜像创建一个容器，并将本地的 /home/alex/alex 目录，挂载到容器中的 /usr/local/demo 目录 docker run -di -v /home/alex/alex:/usr/local/demo centos 导出和导入容器 导出容器快照 docker export > # 比如将容器 id 为 7691a814370e 的容器导出快照为 alex.tar docker export 7691a814370e > alex.tar 导入容器快照 cat | docker import - /: # 比如将容器快照文件 alex.tar 导入到 alex-demo 镜像并定义 alex-demo 镜像的作者为 alex，版本号为 v1.0 cat alex.tar | docker import - alex/alex-demo:v1.0 # 此外，也可以通过指定 url 或者某个目录来导入 docker import http://example.com/example-image.tgz example/image-repo:v1.0 书籍 Docker -- 从入门到实战 Docker 边学边用 一文了解 Kubernetes Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 08:57:33 "},"doc/docker-notes/about-laradock.html":{"url":"doc/docker-notes/about-laradock.html","title":"laradock 笔记","keywords":"","body":"laradock 笔记 官方文档 中文文档 在 Mac/Windows 系统中使用 Laradock 搭建基于 Docker 的 Laravel 开发环境 安装步骤 首先将 Laradock 项目代码克隆到本地： git clone https://github.com/Laradock/laradock.git 进入 laradock 目录将 env-example 重命名为 .env： cp env-example .env 然后在 .env 中修改镜像构建过程中 Linux 软件源为国内镜像以免镜像构建过程中出现网络超时问题： CHANGE_SOURCE # If you need to change the sources (i.e. to China), set CHANGE_SOURCE to true CHANGE_SOURCE=true # Set CHANGE_SOURCE and UBUNTU_SOURCE option if you want to change the Ubuntu system sources.list file. UBUNTU_SOURCE=aliyun 构建镜像 & 启动容器： docker-compose up -d nginx mysql redis beanstalkd nginx 镜像构建在 php-fpm 之上，php-fpm 构建在 workspace 之上，所以启动 nginx 会先启动 workspace 和 php-fpm。 如果指定端口已经被占用，运行上述命令会报错，关闭相应的服务再重新运行上述命令即可。 如果在 Windows 系统中上述指令构建镜像过程中报错： /tmp/sources.sh: not found 可参考这个 issue 解决：https://github.com/laradock/laradock/issues/2450。 打开 Laravel 项目的 .env 文件并添加如下配置： DB_HOST=mysql # 这里填写容器的名称（比如：laradock_redis_1）或者容器的 ip 地址（比如：172.28.0.5）也可以 REDIS_HOST=redis QUEUE_HOST=beanstalkd 其他命令 构建镜像 & 启动容器 docker-compose up -d nginx mysql redis beanstalkd 重新构建容器 # 比如：重新构建 mysql 容器 docker-compose build mysql 增加一个项目之后,重启 Docker 的 nginx docker-compose up -d nginx 列出容器 # 列出正在运行的容器 docker ps # 如果你只想看当前这个项目的容器，你也可以执行下面这个命令 docker-compose ps 重启当前这个项目中的所有容器（如果你不想一个一个的开启每一个容器，可以方便的执行这条命令） docker-compose restart 关闭容器 # 关闭所有正在运行的容器 docker-compose stop # 停止单个容器 docker-compose stop {container-name} 进入容器 # 使用下面的命令进入任意容器 docker-compose exec {container-name} bash # 进入 mysql 容器 docker-compose exec mysql bash # 进入 mysql 并在 mysql 容器中使用命令提示符 docker-compose exec mysql mysql -u homestead -psecret # 进入 workspace 容器,执行比如(Artisan, Composer, PHPUnit, Gulp, ...)等命令 docker-compose exec workspace bash 删除所有现有容器 docker-compose down 查看日志文件NGINX 日志文件存储在logs/nginx目录中但是要查看其他容器（Mysql，PHP-FPM,...）的日志，可以运行以下命令 docker-compose logs {container-name} docker-compose logs -f {container-name} 在 laradock 中安装 swoole 在本地安装的话，以 Laradock 为例，需要在 laradock 目录下的 .env 中将下面两行配置值设置为 true： WORKSPACE_INSTALL_SWOOLE=true PHP_FPM_INSTALL_SWOOLE=true 然后运行 docker-compose build php-fpm workspace 重新构建 Docker 容器，构建完成后重启这两个容器，进入 workspace 容器，运行 php -m 查看 Swoole 是否安装成功，如果扩展列表包含 swoole 则表示安装成功。 其他需要注意事项 在 laravel 框架中，如果配置不生效，请注意清理下 laravel 的缓存 php artisan config:clear 检查下是否开启了 5200 端口 安装 netstat 命令，查看端口apt-get updateapt-get install net-toolsnetstat -ntlp netstat -ant | grep 5200 端口映射开启方式 进入 laradock/docker-compose.yml 在 workspace 下的 ports 中新增 ports: - \"${WORKSPACE_SSH_PORT}:22\" - \"${WORKSPACE_VUE_CLI_SERVE_HOST_PORT}:8080\" - \"${WORKSPACE_VUE_CLI_UI_HOST_PORT}:8000\" - \"${WORKSPACE_PORT}:5200\" /**这一行为新增的行，也可以直接在这里加 5200:5200 这样加了之后，就不再需要在 .env 中设置变量了**/ 进入 .env 在 WORKSPACE 下最后一行增加 WORKSPACE_AST_VERSION=1.0.3 WORKSPACE_VUE_CLI_SERVE_HOST_PORT=8080 WORKSPACE_VUE_CLI_UI_HOST_PORT=8001 WORKSPACE_INSTALL_GIT_PROMPT=false WORKSPACE_PORT=5200 /**这一行为新增的行，其实就是设置步骤 1 中的变量**/ 有些博客说还需要在 laradock/workspace/Dockerfile 文件的最后添加一行，申明开放端口： EXPOSE 5200，这里，我并没有做这一步，同样也成功了，如果你没有成功，你加上去之后再试试看吧 强制重新创建 workspace 容器 docker-compose up -d --force-recreate workspace 重启 docker-compose docker-compose restart docker ps 测试端口是否开通成功 telnet 127.0.0.1 5200 # 或者直接查看容器的端口列表中是否含有你所需要开通的端口 docker port {container-name} # 比如，如下 docker port laradock_workspace_1 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-07 09:02:31 "},"doc/javascript-notes/basic-grammar.html":{"url":"doc/javascript-notes/basic-grammar.html","title":"JavaScript 基础语法","keywords":"","body":"JavaScript 基础语法 代码书写位置 内嵌到网页中，一般将 JavaScript 代码放到 中 alert('Hello, world'); 单独一个 .js 文件，然后在 html 文件中去引入 JavaScript 并不强制要求在每个语句的结尾加 ; ，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上 ; 。 让 JavaScript 引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。因此，我们不会省略 ; ，所有语句都会添加 ; 。 比较运算 // 它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； false == 0; // true // 它不会自动转换数据类型，如果数据类型不一致，返回 false，如果一致，再比较。 false === 0; // false strict 模式 在 JavaScript 代码的第一行写上 'use strict'; 循环 for 循环 // for 循环 let x = 0; let i; for (i = 1; i while 循环 // while 循环 let x = 0; let n = 10; while (n > 0) { x += n; n -= 2; } console.log(x); // 30 // do ... while let n = 0; do { n += 1; } while (n forEach 循环 （ES5.1 标准引入） // 循环 set let s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element, sameElement, set); }); // 循环 map let m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(key, value, map); }); // 循环数组 let arr = ['A', 'B', 'C']; arr.forEach(function (item, index, array) { console.log(index, item, array); }); // 不可以使用 forEach 去遍历对象 Alex®Artisan, Backend Developer & overall web enthusiastCopyright © Alex all right reservedmodified at: 2021-06-08 10:11:16 "}}